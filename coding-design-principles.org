#+TITLE: Coding Design Principles including SOLID and Design Patterns

I've been reading a lot recently about what is considered good versus bad coding design. This sometimes is also referred to as
/patterns/ and /anti-patterns/ respectively. What I've found is that it comes down to "our experience of things that made life easier".
On the contrary, it's also "things that made life terrible for us -- making trivial tasks harder than they actually should be". In some cases,
there may be some overlap i.e. what person A considers as a good pattern is considered an anti-pattern by person B. In such cases, it usually boils
down to what is the task at hand, what are the requirements, do I need a complicated data structure?, do I need a fancy pattern? etc. As always, in engineering,
it's a matter of taste as well.

Note that most of the principles are language agnostic. However, I'll be using C++ for code examples because
I'm most comfortable with it.

Before getting started, here's a list of resources I found useful when compiling this document:
1) [[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines][C++ Core Guidelines]]
2) [[http://williamdurand.fr/2013/07/30/from-stupid-to-solid-code/][From STUPID to SOLID Code!]]
3) [[https://code.tutsplus.com/series/the-solid-principles--cms-634][The SOLID Principles]]
4) [[https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design][SOLID -- Object Oriented Design]]
5) [[http://blog.gauffin.org/2012/05/solid-principles-with-real-world-examples/][SOLID Principles with real world examples]]
6) [[https://www.codeproject.com/Tips/1033646/SOLID-Principle-with-Csharp-Example][SOLID Principles with C# Examples]]

Note that I'll keep adding to this list as I discover more stuff.

One other thing that I learnt was that most problems in engineering can be solved by abstraction and indirection. Abstraction also involves
simplifying a complicated problems into smaller easily solved problems.

Enough talk, let's get to the coding now!

** SOLID

In general, we are trying to avoid some common themes that are considered as "anti-patterns" in coding:

1) Tight Coupling -- components of your program have too many dependencies on each other. Changing one component affects other components. Such tightly coupled components are difficult to reuse because they most probably can't live on their own due to dependencies. That also makes them harder to test.
2) Duplication -- DRY (Don't repeat yourself): On a basic level, use functions to abstract out common stuff. Note that, these functions should be granular to the point where one function does one thing only, just like a class should be designed to do. Functions should, ideally, also not have side-effects and be pure i.e. invoking the function with the same inputs multiple times should result in the same thing. Such pure functions don't depend on any global state.
3) Indescriptive naming -- Naming stuff is art! Too short and it's not to descriptive; too long and it's hard to read; In general, keep the length of variables, functions, classes as minimum so long as that they describe what they intend to do. Also, functions should be verbs, classes should be nouns or verbs since they have both data and state. I generally name my classes as nouns since that's more natural to me.

I'm sure there are other anti-patterns worth discussing but that's a list to start with. I'll keep updating it as I find more things worth adding here.

Now let's get to SOLID, a set of design principles that help alleviate some of the issues listed above.

SOLID is an acronym; let's go letter by letter:

*** S - Single Responsibility Principle (SRP)
"Every class should have a single responsibility. There should never be more than one reason for a class to change."

Let's look at an example:

#+BEGIN_SRC C++ :exports both
#include <iostream>
#include <vector>

class Shape {
  public:
    virtual ~Shape() = 0;
};

Shape::~Shape() {}

class Circle : public Shape {
  public:
    Circle(int r)
        : radius(r) {}
    int get_radius() const {
        return radius;
    }

  private:
    int radius;
};

class Square : public Shape {
  public:
    Square(int l)
        : length(l) {}
    int get_length() const {
        return length;
    }

  private:
    int length;
};

class AreaCalculator {
  public:
    AreaCalculator(const std::vector<Shape*>& v)
        : shapes(v) {}
    int sum() {
        return 1234; // some logic to calculate sum based on shapes
    }
    void output() {
        std::cout << "The sum is: " << sum() << std::endl;
    }

  private:
    std::vector<Shape*> shapes;
};

int main() {
    Circle c(5);
    Square s(10);
    AreaCalculator calc({&c, &s});
    calc.output();
    return 0;
}

#+END_SRC

#+RESULTS:
: The sum is: 1234

Here, we can see that =AreaCalculator= can calculate the sum of its shapes AND also output the sum.

Now what if instead of outputting to stdout, we want to serialize this to a JSON file? 

Here, SRP is broken because =AreaCalculator= will have to be changed either if we decide to change the sum logic, or if we decide to
change the output format. Instead, we can do something like this:

#+BEGIN_SRC C++ :exports both
#include <iostream>
#include <vector>

class Shape {
  public:
    virtual ~Shape() = 0;
};

Shape::~Shape() {}

class Circle : public Shape {
  public:
    Circle(int r)
        : radius(r) {}
    int get_radius() const {
        return radius;
    }

  private:
    int radius;
};

class Square : public Shape {
  public:
    Square(int l)
        : length(l) {}
    int get_length() const {
        return length;
    }

  private:
    int length;
};

class AreaCalculator {
  public:
    AreaCalculator(const std::vector<Shape*>& v)
        : shapes(v) {}
    int sum() const {
        return 1234; // some logic to calculate sum based on shapes
    }

  private:
    std::vector<Shape*> shapes;
};

class AreaOutputter {
  public:
    AreaOutputter(const AreaCalculator& a)
        : calc(a) {}
    void output1() {
        std::cout << "The sum is: " << calc.sum() << std::endl;
    }
    void output2() {
        std::cout << "Another way of outputting sum is: " << calc.sum()
                  << std::endl;
    }

  private:
    const AreaCalculator& calc;
};

int main() {
    Circle c(5);
    Square s(10);
    AreaCalculator calc({&c, &s});
    AreaOutputter outputter(calc);
    outputter.output2();
    return 0;
}
#+END_SRC

#+RESULTS:
: Another way of outputting sum is: 1234

