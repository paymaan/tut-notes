#+TITLE: Coding Design Principles including SOLID and Design Patterns

I've been reading a lot recently about what is considered good versus bad coding design. This sometimes is also referred to as
/patterns/ and /anti-patterns/ respectively. What I've found is that it comes down to "our experience of things that made life easier".
On the contrary, it's also "things that made life terrible for us -- making trivial tasks harder than they actually should be". In some cases,
there may be some overlap i.e. what person A considers as a good pattern is considered an anti-pattern by person B. In such cases, it usually boils
down to what is the task at hand, what are the requirements, do I need a complicated data structure?, do I need a fancy pattern? etc. As always, in engineering,
it's a matter of taste as well.

Note that most of the principles are language agnostic.

Before getting started, here's a list of resources I found useful when compiling this document:
1) [[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines][C++ Core Guidelines]]
2) [[http://williamdurand.fr/2013/07/30/from-stupid-to-solid-code/][From STUPID to SOLID Code!]]
3) [[https://code.tutsplus.com/series/the-solid-principles--cms-634][The SOLID Principles]]
4) [[https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design][SOLID -- Object Oriented Design]]
5) [[http://blog.gauffin.org/2012/05/solid-principles-with-real-world-examples/][SOLID Principles with real world examples]]
6) [[https://www.codeproject.com/Tips/1033646/SOLID-Principle-with-Csharp-Example][SOLID Principles with C# Examples]]

Note that I'll keep adding to this list as I discover more stuff.

One other thing that I learnt was that most problems in engineering can be solved by abstraction and indirection. Abstraction also involves
simplifying a complicated problem into smaller easily solved problems.

Enough talk, let's get to the coding now!

** SOLID

In general, we are trying to avoid some common themes that are considered as "anti-patterns" in coding:

1) Tight Coupling -- components of your program have too many dependencies on each other. Changing one component affects other components. Such tightly coupled components are difficult to reuse because they most probably can't live on their own due to dependencies. That also makes them harder to test.
2) Duplication -- DRY (Don't repeat yourself): On a basic level, use functions to abstract out common stuff. Note that, these functions should be granular to the point where one function does one thing only, just like a class should be designed to do. Functions should, ideally, also not have side-effects and be pure i.e. invoking the function with the same inputs multiple times should result in the same thing. Such pure functions don't depend on any global state.
3) Indescriptive naming -- Naming stuff is art! Too short and it's not to descriptive; too long and it's hard to read; In general, keep the length of variables, functions, classes as minimum so long as that they describe what they intend to do. Also, functions should be verbs, classes should be nouns or verbs since they have both data and state. I generally name my classes as nouns since that's more natural to me.

I'm sure there are other anti-patterns worth discussing but that's a list to start with. I'll keep updating it as I find more things worth adding here.

Now let's get to SOLID, a set of design principles that help alleviate some of the issues listed above.

SOLID is an acronym; let's go letter by letter:

*** S - Single Responsibility Principle (SRP)
"Every class should have a single responsibility. There should never be more than one reason for a class to change."

Let's look at an example:

#+BEGIN_SRC C++ :exports both
#include <iostream>
#include <vector>

class Shape {
  public:
    virtual ~Shape() = 0;
};

Shape::~Shape() {}

class Circle : public Shape {
  public:
    Circle(int r)
        : radius(r) {}
    int get_radius() const {
        return radius;
    }

  private:
    int radius;
};

class Square : public Shape {
  public:
    Square(int l)
        : length(l) {}
    int get_length() const {
        return length;
    }

  private:
    int length;
};

class AreaCalculator {
  public:
    AreaCalculator(const std::vector<Shape*>& v)
        : shapes(v) {}
    int sum() {
        return 1234; // some logic to calculate sum based on shapes
    }
    void output() {
        std::cout << "The sum is: " << sum() << std::endl;
    }

  private:
    std::vector<Shape*> shapes;
};

int main() {
    Circle c(5);
    Square s(10);
    AreaCalculator calc({&c, &s});
    calc.output();
    return 0;
}

#+END_SRC

#+RESULTS:
: The sum is: 1234

Here, we can see that =AreaCalculator= can calculate the sum of its shapes AND also output the sum.

Now what if instead of outputting to stdout, we want to serialize this to a JSON file? 

Here, SRP is broken because =AreaCalculator= will have to be changed either if we decide to change the sum logic, or if we decide to
change the output format. Instead, we can do something like this:

#+BEGIN_SRC C++ :exports both
#include <iostream>
#include <vector>

class Shape {
  public:
    virtual ~Shape() = 0;
};

Shape::~Shape() {}

class Circle : public Shape {
  public:
    Circle(int r)
        : radius(r) {}
    int get_radius() const {
        return radius;
    }

  private:
    int radius;
};

class Square : public Shape {
  public:
    Square(int l)
        : length(l) {}
    int get_length() const {
        return length;
    }

  private:
    int length;
};

class AreaCalculator {
  public:
    AreaCalculator(const std::vector<Shape*>& v)
        : shapes(v) {}
    int sum() const {
        return 1234; // some logic to calculate sum based on shapes
    }

  private:
    std::vector<Shape*> shapes;
};

class AreaOutputter {
  public:
    AreaOutputter(const AreaCalculator& a)
        : calc(a) {}
    void output1() {
        std::cout << "The sum is: " << calc.sum() << std::endl;
    }
    void output2() {
        std::cout << "Another way of outputting sum is: " << calc.sum()
                  << std::endl;
    }

  private:
    const AreaCalculator& calc;
};

int main() {
    Circle c(5);
    Square s(10);
    AreaCalculator calc({&c, &s});
    AreaOutputter outputter(calc);
    outputter.output2();
    return 0;
}
#+END_SRC

#+RESULTS:
: Another way of outputting sum is: 1234

Note that although we discussed classes here, SRP can be applied to functions as well i.e. functions should only have one reason to change.

*** O - Open/Closed Principle (OCP)
"Objects or entities should be open for extension, but closed for modification."

**** Example 1

Copied from =scotch.io=:

This simply means that a class should be easily extendable without modifying the class itself. Let's take a look at the AreaCalculator class, especially it's sum method.

#+BEGIN_SRC C++ :exports both
public function sum() {
    foreach($this->shapes as $shape) {
        if(is_a($shape, 'Square')) {
            $area[] = pow($shape->length, 2);
        } else if(is_a($shape, 'Circle')) {
            $area[] = pi() * pow($shape->radius, 2);
        }
    }

    return array_sum($area);
}  
#+END_SRC

If we wanted the sum method to be able to sum the areas of more shapes, we would have to add more if/else blocks and that goes against the Open-closed principle
since we have to modify =sum()= whenever we have a new shape i.e. it's not close to modification. Instead, we can make it extensible.

A way we can make this sum method better is to remove the logic to calculate the area of each shape out of the sum method and attach it to the shape's class.

#+BEGIN_SRC C++ :exports both
class Square {
    public $length;

    public function __construct($length) {
        $this->length = $length;
    }

    public function area() {
        return pow($this->length, 2);
    }
}   
#+END_SRC

The same thing should be done for the Circle class, an area method should be added. Now, to calculate the sum of any shape provided should be as simple as:

#+BEGIN_SRC C++ :exports both
public function sum() {
    foreach($this->shapes as $shape) {
        $area[] = $shape->area();
    }

    return array_sum($area);
}
#+END_SRC

Now we can create another shape class and pass it in when calculating the sum without breaking our code. However, now another problem arises, how do we know that the object passed into the AreaCalculator is actually a shape or if the shape has a method named area?

Coding to an interface is an integral part of S.O.L.I.D, a quick example is we create an interface, that every shape implements:

#+BEGIN_SRC C++ :exports both
interface ShapeInterface {
    public function area();
}

class Circle implements ShapeInterface {
    public $radius;

    public function __construct($radius) {
        $this->radius = $radius;
    }

    public function area() {
        return pi() * pow($this->radius, 2);
    }
} 
#+END_SRC

In our AreaCalculator sum method we can check if the shapes provided are actually instances of the ShapeInterface, otherwise we throw an exception:

#+BEGIN_SRC C++ :exports both
public function sum() {
    foreach($this->shapes as $shape) {
        if(is_a($shape, 'ShapeInterface')) {
            $area[] = $shape->area();
            continue;
        }

        throw new AreaCalculatorInvalidShapeException;
    }

    return array_sum($area);
} 
#+END_SRC

**** Example 2

Use [[https://code.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600][Strategy Design Pattern]]

**** Example 3

Use [[http://www.craftinginterpreters.com/representing-code.html#the-visitor-pattern][Visitor Design Pattern]]
