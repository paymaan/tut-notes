#+TITLE: Coding Design Principles including SOLID and Design Patterns

I've been reading a lot recently about what is considered good versus bad coding design. This sometimes is also referred to as
/patterns/ and /anti-patterns/ respectively. What I've found is that it comes down to "our experience of things that made life easier".
On the contrary, it's also "things that made life terrible for us -- making trivial tasks harder than they actually should be". In some cases,
there may be some overlap i.e. what person A considers as a good pattern is considered an anti-pattern by person B. In such cases, it usually boils
down to what is the task at hand, what are the requirements, do I need a complicated data structure?, do I need a fancy pattern? etc. As always, in engineering,
it's a matter of taste as well.

Note that most of the principles are language agnostic. However, I'll be using C++ for code examples because
I'm most comfortable with it.

Before getting started, here's a list of resources I found useful when compiling this document:
1) [[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines][C++ Core Guidelines]]
2) [[http://williamdurand.fr/2013/07/30/from-stupid-to-solid-code/][From STUPID to SOLID Code!]]
3) [[https://code.tutsplus.com/series/the-solid-principles--cms-634][The SOLID Principles]]
4) [[https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design][SOLID -- Object Oriented Design]]
5) [[http://blog.gauffin.org/2012/05/solid-principles-with-real-world-examples/][SOLID Principles with real world examples]]
6) [[https://www.codeproject.com/Tips/1033646/SOLID-Principle-with-Csharp-Example][SOLID Principles with C# Examples]]

Note that I'll keep adding to this list as I discover more stuff.

Enough talk, let's get to the coding now!

** SOLID

In general, we are trying to avoid some common themes that are considered as "anti-patterns" in coding:

1) Tight Coupling -- components of your program have too many dependencies on each other. Changing one component affects other components. Such tightly coupled components are difficult to reuse because they most probably can't live on their own due to dependencies. That also makes them harder to test.
2) Duplication -- DRY (Don't repeat yourself): On a basic level, use functions to abstract out common stuff. Note that, these functions should be granular to the point where one function does one thing only, just like a class should be designed to do. Functions should, ideally, also not have side-effects and be pure i.e. invoking the function with the same inputs multiple times should result in the same thing. Such pure functions don't depend on any global state.
3) Indescriptive naming -- Naming stuff is art! Too short and it's not to descriptive; too long and it's hard to read; In general, keep the length of variables, functions, classes as minimum so long as that they describe what they intend to do. Also, functions should be verbs, classes should be nouns or verbs since they have both data and state. I generally name my classes as nouns since that's more natural to me.

I'm sure there are other anti-patterns worth discussing but that's a list to start with. I'll keep updating it as I find more things worth adding here.

Now let's get to SOLID, a set of design principles that help alleviate some of the issues listed above.

SOLID is an acronym; let's go letter by letter:

*** S - Single Responsibility Principle





