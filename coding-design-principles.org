#+TITLE: Coding Design Principles including UML, SOLID Principles, and Design Patterns

I've been reading a lot recently about what is considered good versus bad coding design. This sometimes is also referred to as
/patterns/ and /anti-patterns/ respectively. What I've found is that it comes down to "our experience of things that made life easier".
On the contrary, it's also "things that made life terrible for us -- making trivial tasks harder than they actually should be". In some cases,
there may be some overlap i.e. what person A considers as a good pattern is considered an anti-pattern by person B. In such cases, it usually boils
down to what is the task at hand, what are the requirements, do I need a complicated data structure?, do I need a fancy pattern? etc. As always, in engineering,
it's a matter of taste as well.

Note that most of the principles are language agnostic.

Before getting started, here's a list of resources I found useful when compiling this document:
1) [[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines][C++ Core Guidelines]]
2) [[http://williamdurand.fr/2013/07/30/from-stupid-to-solid-code/][From STUPID to SOLID Code!]]
3) [[https://code.tutsplus.com/series/the-solid-principles--cms-634][The SOLID Principles]]
4) [[https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design][SOLID -- Object Oriented Design]]
5) [[http://blog.gauffin.org/2012/05/solid-principles-with-real-world-examples/][SOLID Principles with real world examples]]
6) [[https://www.codeproject.com/Tips/1033646/SOLID-Principle-with-Csharp-Example][SOLID Principles with C# Examples]]

Note that I'll keep adding to this list as I discover more stuff.

One other thing that I learnt was that most problems in engineering can be solved by abstraction and indirection. Abstraction also involves
simplifying a complicated problem into smaller easily solved problems.

Enough talk, let's get to the coding now!

** SOLID

In general, we are trying to avoid some common themes that are considered as "anti-patterns" in coding:

1) Tight Coupling -- components of your program have too many dependencies on each other. Changing one component affects other components. Such tightly coupled components are difficult to reuse because they most probably can't live on their own due to dependencies. That also makes them harder to test.
2) Duplication -- DRY (Don't repeat yourself): On a basic level, use functions to abstract out common stuff. Note that, these functions should be granular to the point where one function does one thing only, just like a class should be designed to do. Functions should, ideally, also not have side-effects and be pure i.e. invoking the function with the same inputs multiple times should result in the same thing. Such pure functions don't depend on any global state.
3) Indescriptive naming -- Naming stuff is art! Too short and it's not to descriptive; too long and it's hard to read; In general, keep the length of variables, functions, classes as minimum so long as that they describe what they intend to do. Also, functions should be verbs, classes should be nouns or verbs since they have both data and state. I generally name my classes as nouns since that's more natural to me.

I'm sure there are other anti-patterns worth discussing but that's a list to start with. I'll keep updating it as I find more things worth adding here.

Now let's get to SOLID, a set of design principles that help alleviate some of the issues listed above.

SOLID is an acronym; let's go letter by letter:

*** S - Single Responsibility Principle (SRP)
"Every class should have a single responsibility. There should never be more than one reason for a class to change."

Let's look at an example:

#+BEGIN_SRC C++ :exports both
#include <iostream>
#include <vector>

class Shape {
  public:
    virtual ~Shape() = 0;
};

Shape::~Shape() {}

class Circle : public Shape {
  public:
    Circle(int r)
        : radius(r) {}
    int get_radius() const {
        return radius;
    }

  private:
    int radius;
};

class Square : public Shape {
  public:
    Square(int l)
        : length(l) {}
    int get_length() const {
        return length;
    }

  private:
    int length;
};

class AreaCalculator {
  public:
    AreaCalculator(const std::vector<Shape*>& v)
        : shapes(v) {}
    int sum() {
        return 1234; // some logic to calculate sum based on shapes
    }
    void output() {
        std::cout << "The sum is: " << sum() << std::endl;
    }

  private:
    std::vector<Shape*> shapes;
};

int main() {
    Circle c(5);
    Square s(10);
    AreaCalculator calc({&c, &s});
    calc.output();
    return 0;
}

#+END_SRC

#+RESULTS:
: The sum is: 1234

Here, we can see that =AreaCalculator= can calculate the sum of its shapes AND also output the sum.

Now what if instead of outputting to stdout, we want to serialize this to a JSON file? 

Here, SRP is broken because =AreaCalculator= will have to be changed either if we decide to change the sum logic, or if we decide to
change the output format. Instead, we can do something like this:

#+BEGIN_SRC C++ :exports both
#include <iostream>
#include <vector>

class Shape {
  public:
    virtual ~Shape() = 0;
};

Shape::~Shape() {}

class Circle : public Shape {
  public:
    Circle(int r)
        : radius(r) {}
    int get_radius() const {
        return radius;
    }

  private:
    int radius;
};

class Square : public Shape {
  public:
    Square(int l)
        : length(l) {}
    int get_length() const {
        return length;
    }

  private:
    int length;
};

class AreaCalculator {
  public:
    AreaCalculator(const std::vector<Shape*>& v)
        : shapes(v) {}
    int sum() const {
        return 1234; // some logic to calculate sum based on shapes
    }

  private:
    std::vector<Shape*> shapes;
};

class AreaOutputter {
  public:
    AreaOutputter(const AreaCalculator& a)
        : calc(a) {}
    void output1() {
        std::cout << "The sum is: " << calc.sum() << std::endl;
    }
    void output2() {
        std::cout << "Another way of outputting sum is: " << calc.sum()
                  << std::endl;
    }

  private:
    const AreaCalculator& calc;
};

int main() {
    Circle c(5);
    Square s(10);
    AreaCalculator calc({&c, &s});
    AreaOutputter outputter(calc);
    outputter.output2();
    return 0;
}
#+END_SRC

#+RESULTS:
: Another way of outputting sum is: 1234

Note that although we discussed classes here, SRP can be applied to functions as well i.e. functions should only have one reason to change.

*** O - Open/Closed Principle (OCP)
"Objects or entities should be open for extension, but closed for modification."

**** Example 1

Copied from =scotch.io=:

This simply means that a class should be easily extendable without modifying the class itself. Let's take a look at the AreaCalculator class, especially it's sum method.

#+BEGIN_SRC C++ :exports both
public function sum() {
    foreach($this->shapes as $shape) {
        if(is_a($shape, 'Square')) {
            $area[] = pow($shape->length, 2);
        } else if(is_a($shape, 'Circle')) {
            $area[] = pi() * pow($shape->radius, 2);
        }
    }

    return array_sum($area);
}  
#+END_SRC

If we wanted the sum method to be able to sum the areas of more shapes, we would have to add more if/else blocks and that goes against the Open-closed principle
since we have to modify =sum()= whenever we have a new shape i.e. it's not close to modification. Instead, we can make it extensible.

A way we can make this sum method better is to remove the logic to calculate the area of each shape out of the sum method and attach it to the shape's class.

#+BEGIN_SRC C++ :exports both
class Square {
    public $length;

    public function __construct($length) {
        $this->length = $length;
    }

    public function area() {
        return pow($this->length, 2);
    }
}   
#+END_SRC

The same thing should be done for the =Circle= class, an area method should be added. Now, to calculate the sum of any shape provided should be as simple as:

#+BEGIN_SRC C++ :exports both
public function sum() {
    foreach($this->shapes as $shape) {
        $area[] = $shape->area();
    }

    return array_sum($area);
}
#+END_SRC

Now we can create another shape class and pass it in when calculating the sum without breaking our code. However, now another problem arises, how do we know that the object passed into the AreaCalculator is actually a shape or if the shape has a method named area?

Coding to an interface is an integral part of S.O.L.I.D, a quick example is we create an interface, that every shape implements:

#+BEGIN_SRC C++ :exports both
interface ShapeInterface {
    public function area();
}

class Circle implements ShapeInterface {
    public $radius;

    public function __construct($radius) {
        $this->radius = $radius;
    }

    public function area() {
        return pi() * pow($this->radius, 2);
    }
} 
#+END_SRC

In our =AreaCalculator= sum method we can check if the shapes provided are actually instances of the =ShapeInterface=, otherwise we throw an exception:

#+BEGIN_SRC C++ :exports both
public function sum() {
    foreach($this->shapes as $shape) {
        if(is_a($shape, 'ShapeInterface')) {
            $area[] = $shape->area();
            continue;
        }

        throw new AreaCalculatorInvalidShapeException;
    }

    return array_sum($area);
} 
#+END_SRC

**** Example 2

Use [[https://code.tutsplus.com/tutorials/solid-part-2-the-openclosed-principle--net-36600][Strategy Design Pattern]]

**** Example 3

Use [[http://www.craftinginterpreters.com/representing-code.html#the-visitor-pattern][Visitor Design Pattern]]

*** L - Liskov Substitution Principle (LSP)

"Objects in a program should be replaceable with instances of their subtypes without altering the correctness of the program."

**** Example 1

In languages with compile-time type checking, LSP is pretty obvious since we'll catch any violations at compile-time:

#+BEGIN_SRC C++ :exports both
class Vehicle {
 
    function startEngine() {
        // Default engine start functionality
    }
 
    function accelerate() {
        // Default acceleration functionality
    }
}

class Car extends Vehicle {
 
    function startEngine() {
        $this->engageIgnition();
        parent::startEngine();
    }
 
    private function engageIgnition() {
        // Ignition procedure
    }
 
}
 
class ElectricBus extends Vehicle {
 
    function accelerate() {
        $this->increaseVoltage();
        $this->connectIndividualEngines();
    }
 
    private function increaseVoltage() {
        // Electric logic
    }
 
    private function connectIndividualEngines() {
        // Connection logic
    }
 
}

class Driver {
    function go(Vehicle $v) {
        $v->startEngine();
        $v->accelerate();
    }
}
#+END_SRC

**** Example 2

In dynamically typed languages, we can get run-time errors. Copied from =scotch.io=:

Still making use of out =AreaCalculator= class, say we have a =VolumeCalculator= class that extends the =AreaCalculator= class:

#+BEGIN_SRC C++ :exports both
class VolumeCalculator extends AreaCalulator {
    public function __construct($shapes = array()) {
        parent::__construct($shapes);
    }

    public function sum() {
        // logic to calculate the volumes and then return and array of output
        return array($summedData);
    }
}

class SumCalculatorOutputter {
    protected $calculator;

    public function __constructor(AreaCalculator $calculator) {
        $this->calculator = $calculator;
    }

    public function JSON() {
        $data = array(
            'sum' => $this->calculator->sum();
        );

        return json_encode($data);
    }

    public function HTML() {
        return implode('', array(
            '',
                'Sum of the areas of provided shapes: ',
                $this->calculator->sum(),
            ''
        ));
    }
}    
#+END_SRC

If we tried to run an example like this:

#+BEGIN_SRC C++ :exports both
$areas = new AreaCalculator($shapes);
$volumes = new AreaCalculator($solidShapes);

$output = new SumCalculatorOutputter($areas);
$output2 = new SumCalculatorOutputter($volumes);

$output2.HTML() // error!
#+END_SRC

The program does not squawk, but when we call the =HTML= method on the $output2 object we get an E_NOTICE error informing us of an array to string conversion.

To fix this, instead of returning an array from the VolumeCalculator class sum method, you should simply:

#+BEGIN_SRC C++ :exports both
public function sum() {
    // logic to calculate the volumes and then return and array of output
    return $summedData; // summed data as float, double, or integer
}
#+END_SRC
*** I - Interface Segregation Principle (ISP)
"A client should never be forced to implement an interface that it doesn't use or clients shouldn't be forced to depend on methods they do not use."

**** Example 1
Copied from =scotch.io=:

Still using our shapes example, we know that we also have solid shapes, so since we would also want to calculate the volume of the shape, we 
can add another contract to the =ShapeInterface=:

#+BEGIN_SRC C++ :exports both
interface ShapeInterface {
    public function area();
    public function volume();
}
#+END_SRC

Any shape we create must implement the =volume= method, but we know that squares are flat shapes and that they do not 
have volumes, so this interface would force the Square class to implement a method that it has no use of.

ISP says no to this, instead you could create another interface called =SolidShapeInterface= that has the volume contract and solid 
shapes like cubes e.t.c can implement this interface:

#+BEGIN_SRC C++ :exports both
interface ShapeInterface {
    public function area();
}

interface SolidShapeInterface {
    public function volume();
}

class Cuboid implements ShapeInterface, SolidShapeInterface {
    public function area() {
        // calculate the surface area of the cuboid
    }

    public function volume() {
        // calculate the volume of the cuboid
    }
}
#+END_SRC

This is a much better approach, but a pitfall to watch out for is when type-hinting these interfaces, instead 
of using a =ShapeInterface= or a =SolidShapeInterface=.

You can create another interface, maybe =ManageShapeInterface=, and implement it on both the flat and solid 
shapes, this way you can easily see that it has a single API for managing the shapes. For example:

#+BEGIN_SRC C++ :exports both
interface ManageShapeInterface {
    public function calculate();
}

class Square implements ShapeInterface, ManageShapeInterface {
    public function area() { /*Do stuff here*/ }

    public function calculate() {
        return $this->area();
    }
}

class Cuboid implements ShapeInterface, SolidShapeInterface, ManageShapeInterface {
    public function area() { /*Do stuff here*/ }
    public function volume() { /*Do stuff here*/ }

    public function calculate() {
        return $this->area() + $this->volume();
    }
}
#+END_SRC

Now in =AreaCalculator= class, we can easily replace the call to the area method with calculate and also check if the object is an 
instance of the =ManageShapeInterface= and not the =ShapeInterface=.

*** D - Dependency Inversion Principle (DIP)
"High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend upon abstractions."

**** Example 1

Copied from =scotch.io=:
This might sound bloated, but it is really easy to understand. This principle allows for decoupling, an example that seems like the best way to explain this principle:

#+BEGIN_SRC C++ :exports both
class PasswordReminder {
    private $dbConnection;

    public function __construct(MySQLConnection $dbConnection) {
        $this->dbConnection = $dbConnection;
    }
}
#+END_SRC

First the MySQLConnection is the low level module while the PasswordReminder is high level, but according to the definition of D in S.O.L.I.D. which states that Depend on Abstraction not on concretions, this snippet above violates this principle as the PasswordReminder class is being forced to depend on the MySQLConnection class.

Later if you were to change the database engine, you would also have to edit the PasswordReminder class and thus violates Open-close principle.

The PasswordReminder class should not care what database your application uses, to fix this again we "code to an interface", since high level and low level modules should depend on abstraction, we can create an interface:

#+BEGIN_SRC C++ :exports both
interface DBConnectionInterface {
    public function connect();
}    
#+END_SRC

The interface has a connect method and the MySQLConnection class implements this interface, also instead of directly type-hinting MySQLConnection class in the constructor of the PasswordReminder, we instead type-hint the interface and no matter the type of database your application uses, the PasswordReminder class can easily connect to the database without any problems and OCP is not violated.

#+BEGIN_SRC C++ :exports both
class MySQLConnection implements DBConnectionInterface {
    public function connect() {
        return "Database connection";
    }
}

class PasswordReminder {
    private $dbConnection;

    public function __construct(DBConnectionInterface $dbConnection) {
        $this->dbConnection = $dbConnection;
    }
}
#+END_SRC

According to the little snippet above, you can now see that both the high level and low level modules depend on abstraction.

**** Example 2

A fantastic example of DIP which uses EReader and PDFBook can be found [[https://code.tutsplus.com/tutorials/solid-part-4-the-dependency-inversion-principle--net-36872][here]].








** UML
I think for UML (Universal Modeling Language), there are many resources on the internet that give good pictorial description
of things. This section will basically be just a collection of such resources along with some of my personal notes
based on what I've read on blogs, stack overflow, seen at work etc. Notice, however, that I'll just focus on the OOP and class diagram portion of 
UML, probably also a bit sequence diagrams. I /think/ UML is much more than that as can be found [[https://en.wikipedia.org/wiki/Unified_Modeling_Language][here]].

Some good links:
1. [[http://pl.cs.jhu.edu/oose/resources/uml-cheatsheet.pdf][UML Cheat Sheet]]
2. [[https://courses.cs.washington.edu/courses/cse403/11sp/lectures/lecture08-uml1.pdf][UWashington Notes - Class Diagrams]]
3. [[https://courses.cs.washington.edu/courses/cse403/11sp/lectures/lecture09-uml2.pdf][UWashington Notes - Sequence Diagrams]]
4. [[http://www.cc.ntut.edu.tw/~wkchen/courses/gposd/gposd981/IntroUML.pdf][NTUT Notes]]
5. [[https://cppcodetips.wordpress.com/2013/12/23/uml-class-diagram-explained-with-c-samples/][UML with C++ examples]]
6. [[https://www.codeproject.com/Articles/618/OOP-and-UML][Codeproject UML]]
7. [[http://handmade.iptime.org/w/public/uml_class_diagram_explained_with_c_samples/][UML with more C++ examples]]

The above links also explains the difference between association, aggregation, and composition.
