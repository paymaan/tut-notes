#+TITLE: My Python notes

I tend to learn by example but also forget language syntax and semantics if I don't program using in that language for some time. So
I've made it a habit to capture notes (mostly concepts and examples). These notes are based on: https://bugs.python.org/file47781/Tutorial_EDIT.pdf.

* Concepts

** Python memory model

A variable (with name) is a reference to an object in memory. So every variable is just a memory address to some object.

The actual object is the "value" of the variable. A type is associated with the object at run-time.

The compiler can optimize e.g. multiple variables can point to the same object in memory.

Python is not strongly typed.

One way to classify types is that they're either mutable or immutable e.g. List is mutable but a String is not. Since objects
are associated with types, python has mutable objects or immutable objects.

When you pass variables around through functions, you are not doing the traditional pass by value or pass by reference. Rather, 
you're really just passing the object. 

If you pass a mutable object e.g. a List, you're essentially binding a new variable (reference) 
inside that function to that object. That means you can mutate it. Having said that, if you do var = something, that
something would be a new object and won't mutate the original object. Instead for things like List, use append for example.

For immutable objects, you are also doing the same, except when you try to mutate it, Python would create a new immutable 
object in memory, and bind the variable to that object. That means that even though it may seem that you're changing 
the variable's value inside the function, what you're really doing is creating a new value object whose life cycle is 
the same as that of the function. So the variable outside the function, even after the function's execution, would 
have the same old value (since it is bound to the same old immutable object).

More details about this are well described here: http://stupidpythonideas.blogspot.com/2013/11/does-python-pass-by-value-or-by.html

Let's use an example to illustrate this:

#+BEGIN_SRC python :results output :exports both
  # id uniquely identifies variable, "like" a memory address; hex(id) can give address based on interpreter
  def memAddr(var):
    return hex(id(var))

  a1, a2, a3 = 1, 1, 2
  b1, b2, b3 = "abc", "abc", "Abc"
  c1, c2, c3 = ['1', '2'], ['1', '2'], ['2', '1']

  # Immutable objects are optimized and share the same object
  print(memAddr(a1), memAddr(a2), memAddr(a3))
  print(memAddr(b1), memAddr(b2), memAddr(b3))
  # Mutable objects generally assigned new object from get go
  print(memAddr(c1), memAddr(c2), memAddr(c3))

  def foo_immutable_str(var):
    var = "abcd"
    print(memAddr(var))

  def foo_mutable_list(var):
    var.append('3')
    print(memAddr(var))

  print(b1)
  foo_immutable_str(b1)
  print(b1)

  print(c1)
  foo_mutable_list(c1)
  print(c1)
#+END_SRC

#+RESULTS:
: ('0x7ff1e7d05718', '0x7ff1e7d05718', '0x7ff1e7d05700')
: ('0x106519dc8', '0x106519dc8', '0x106519e18')
: ('0x1064b2f38', '0x1064d8098', '0x1064e8170')
: abc
: 0x1064e5ed0
: abc
: ['1', '2']
: 0x1064b2f38
: ['1', '2', '3']

* Basics, Features, Examples

** Types
As with any mainstream language, Python has a lot of types.

To categorize, they can be broken into primitive or built-in types and user-defined 
types (classes, enums).

There are also container types (made up of primitive types). Typically, these 
types have some specific properties that make them special. Containers types can 
be broken down into ordered sequence types (list, tuple, etc.) and key/association types (set, dict).

Details of Pyhon3 types can be found here: https://docs.python.org/3/library/stdtypes.html

High level list can be found here: https://docs.python.org/2/library/types.html

Let's cover primitive types first:

#+BEGIN_SRC python :results output :exports both
a, b, c, d, e, f = 12, int(12), -12, 12.456, float(12.456), 1 * 10**9
print(a, b, c, d, e, f)
# Note that d (1 billion) is also an int
# Python 3 made every number int: https://stackoverflow.com/questions/2104884/how-does-python-manage-int-and-long
print(type(a), type(b), type(c), type(d), type(e), type(f))

g, h, i = "abc", 'abc', str("abc")
print(g, h, i)
print(type(g), type(h), type(i))

j, k = True, bool(False)
print(j, k)
print(type(j), type(k))

l = bytes(123)
print(l)
#+END_SRC

#+RESULTS:
: (12, 12, -12, 12.456, 12.456, 1000000000)
: (<type 'int'>, <type 'int'>, <type 'int'>, <type 'float'>, <type 'float'>, <type 'int'>)
: ('abc', 'abc', 'abc')
: (<type 'str'>, <type 'str'>, <type 'str'>)
: (True, False)
: (<type 'bool'>, <type 'bool'>)
: 123

There are also binary types such as bytes, bytearray, memoryview. Read about these
here: https://www.w3resource.com/python/python-bytes.php

Now let's see some container types:

#+BEGIN_SRC python :results output :exports both
a, b = [1, 2, 3], list([1, 2, 3])
print(a, b)
print(type(a),type(b))

c, d, d1 = (), (1, "2", 3.4), tuple((1, "2", 3.4))
print(c, d, d1)
print(type(c), type(d), type(d1))

e, f = set({1, 2, 3}), {1, 2, 3} # note {} is dict so empty set must be created using set()
print(e, f)
print(type(e), type(f))

g, h = {}, {"a": 2, "b": 6} # dict() usage was complicated for me
print(g, h)
print(type(g), type(h))

i = None # similar to nullptr in C++ and null in Java
print(i)
print(type(i))
#+END_SRC

#+RESULTS:
#+begin_example
([1, 2, 3], [1, 2, 3])
(<type 'list'>, <type 'list'>)
((), (1, '2', 3.4), (1, '2', 3.4))
(<type 'tuple'>, <type 'tuple'>, <type 'tuple'>)
(set([1, 2, 3]), set([1, 2, 3]))
(<type 'set'>, <type 'set'>)
({}, {'a': 2, 'b': 6})
(<type 'dict'>, <type 'dict'>)
None
<type 'NoneType'>
#+end_example

** Control flow

If statements:

#+BEGIN_SRC python :results output :exports both
  x = 12
  if x < 0:
    print("blah")
  elif x > 0:
    print("something")
  else:
    print("x is zero")
#+END_SRC

#+RESULTS:
: something

For statements:

#+BEGIN_SRC python :results output :exports both
a = range(0, 10) # list in python2, iterator in python3
print(a)
print(list(a))

b = range(0, 10, 2)
print(list(b))

c = range(10, 0, -1)
print(list(c))

for i in range(0, 10):
    print(i, end=" ") # end only supported in python3
#+END_SRC

#+RESULTS:
: range(0, 10)
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
: [0, 2, 4, 6, 8]
: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
: 0 1 2 3 4 5 6 7 8 9

While statements:

#+BEGIN_SRC python :results output :exports both
  i = 0
  while i < 5:
    print(i)
    i += 1
#+END_SRC

#+RESULTS:
: 0
: 1
: 2
: 3
: 4

Apart from range, things like list, sets, and dict (keys) are also iterables.

"break" and "continue" work similar to C/C++/Java.

There's also "pass" which can be used to do nothing.
** Functions
Function definition is simple:

#+BEGIN_SRC python :results output :exports both
  def sum(a, b):
    return a + b

  print(sum(2, 3))

  # functions are objects
  f = sum
  print(f(5, 7))
#+END_SRC

#+RESULTS:
: 5
: 12

Functions can have optional arguments:
#+BEGIN_SRC python :results output :exports both
  def printer(a, b = "b", c = "c"):
    print(a, b, c)

  printer("a")
  printer("a", "e")
  printer("a", "f", "g")
#+END_SRC

#+RESULTS:
: ('a', 'b', 'c')
: ('a', 'e', 'c')
: ('a', 'f', 'g')

Note that optional arguments must come at the end, otherwise there's no
good syntax to call the function, so the compiler would complain.

Functions can also have named arguments (example taken from python notes link at the top):

#+BEGIN_SRC python :results output :exports both
  def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'): 
      print("-- This parrot wouldn't", action)
      print("if you put", voltage, "volts through it.")
      print("-- Lovely plumage, the", type)
      print("-- It's", state, "!")

  parrot(1000) # 1 positional argument
  parrot(voltage=1000 ) # 1 keyword argument
  parrot(voltage=1000000, action='VOOOOOM') # 2 keyword arguments
  parrot(action='VOOOOOM', voltage=1000000) # 2 keyword arguments
  parrot('a million', 'bereft of life', 'jump') # 3 positional arguments
  parrot('a thousand', state='pushing up the daisies') # 1 positional, 1 keyword
#+END_SRC

#+RESULTS:
#+begin_example
("-- This parrot wouldn't", 'voom')
('if you put', 1000, 'volts through it.')
('-- Lovely plumage, the', 'Norwegian Blue')
("-- It's", 'a stiff', '!')
("-- This parrot wouldn't", 'voom')
('if you put', 1000, 'volts through it.')
('-- Lovely plumage, the', 'Norwegian Blue')
("-- It's", 'a stiff', '!')
("-- This parrot wouldn't", 'VOOOOOM')
('if you put', 1000000, 'volts through it.')
('-- Lovely plumage, the', 'Norwegian Blue')
("-- It's", 'a stiff', '!')
("-- This parrot wouldn't", 'VOOOOOM')
('if you put', 1000000, 'volts through it.')
('-- Lovely plumage, the', 'Norwegian Blue')
("-- It's", 'a stiff', '!')
("-- This parrot wouldn't", 'jump')
('if you put', 'a million', 'volts through it.')
('-- Lovely plumage, the', 'Norwegian Blue')
("-- It's", 'bereft of life', '!')
("-- This parrot wouldn't", 'voom')
('if you put', 'a thousand', 'volts through it.')
('-- Lovely plumage, the', 'Norwegian Blue')
("-- It's", 'pushing up the daisies', '!')
#+end_example

Using keyword arguments, you can have optional arguments  out of 
order. (Self note: Have to confirm this and optional argument text above).

There are also lambda or anonymous functions, useful when functions are used
for a one time use-case e.g. as a sort functor in the sort() function. Example:

#+BEGIN_SRC python :results output :exports both
  def get_incrementor(n):
    return lambda x : x + n
  f = get_incrementor(42)
  print(f(3))
#+END_SRC

#+RESULTS:
: 45

Sort example:

#+BEGIN_SRC python :results output :exports both
A = [10, 4, -12, 25, 19]
print(A)
print(sorted(A, key = lambda listElement : listElement * -1)) # sorted is out of place, A.sort will be in-place
#+END_SRC

#+RESULTS:
: [10, 4, -12, 25, 19]
: [25, 19, 10, 4, -12]
* Common tricks
Curated list of tricks I've seen in Python.

Repeat list element N times e.g. create a list of 10 0's. The * operator on list
does exactly that.

#+BEGIN_SRC python :results output :exports both
a = [0] * 10
print(a)

b = [1,2,3] * 3
print(b)
#+END_SRC

#+RESULTS:
: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
: [1, 2, 3, 1, 2, 3, 1, 2, 3]

