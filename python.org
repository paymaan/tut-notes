#+TITLE: My Python notes

I tend to learn by example but also forget language syntax and semantics if I don't program using in that language for some time. So
I've made it a habit to capture notes (mostly concepts and examples). These notes are based on: https://bugs.python.org/file47781/Tutorial_EDIT.pdf.

* Concepts

** Python memory model

A variable (with name) is a reference to an object in memory. So every variable is just a memory address to some object.

The actual object is the "value" of the variable. A type is associated with the object at run-time.

The compiler can optimize e.g. multiple variables can point to the same object in memory.

Python is not strongly typed.

One way to classify types is that they're either mutable or immutable e.g. List is mutable but a String is not. Since objects
are associated with types, python has mutable objects or immutable objects.

When you pass variables around through functions, you are not doing the traditional pass by value or pass by reference. Rather, 
you're really just passing the object. 

If you pass a mutable object e.g. a List, you're essentially binding a new variable (reference) 
inside that function to that object. That means you can mutate it. Having said that, if you do var = something, that
something would be a new object and won't mutate the original object. Instead for things like List, use append for example.

For immutable objects, you are also doing the same, except when you try to mutate it, Python would create a new immutable 
object in memory, and bind the variable to that object. That means that even though it may seem that you're changing 
the variable's value inside the function, what you're really doing is creating a new value object whose life cycle is 
the same as that of the function. So the variable outside the function, even after the function's execution, would 
have the same old value (since it is bound to the same old immutable object).

More details about this are well described here: http://stupidpythonideas.blogspot.com/2013/11/does-python-pass-by-value-or-by.html

Let's use an example to illustrate this:

#+BEGIN_SRC python :results output :exports both
  # id uniquely identifies variable, "like" a memory address; hex(id) can give address based on interpreter
  def memAddr(var):
    return hex(id(var))

  a1, a2, a3 = 1, 1, 2
  b1, b2, b3 = "abc", "abc", "Abc"
  c1, c2, c3 = ['1', '2'], ['1', '2'], ['2', '1']

  # Immutable objects are optimized and share the same object
  print(memAddr(a1), memAddr(a2), memAddr(a3))
  print(memAddr(b1), memAddr(b2), memAddr(b3))
  # Mutable objects generally assigned new object from get go
  print(memAddr(c1), memAddr(c2), memAddr(c3))

  def foo_immutable_str(var):
    var = "abcd"
    print(memAddr(var))

  def foo_mutable_list(var):
    var.append('3')
    print(memAddr(var))

  print(b1)
  foo_immutable_str(b1)
  print(b1)

  print(c1)
  foo_mutable_list(c1)
  print(c1)
#+END_SRC

#+RESULTS:
: ('0x7ff1e7d05718', '0x7ff1e7d05718', '0x7ff1e7d05700')
: ('0x106519dc8', '0x106519dc8', '0x106519e18')
: ('0x1064b2f38', '0x1064d8098', '0x1064e8170')
: abc
: 0x1064e5ed0
: abc
: ['1', '2']
: 0x1064b2f38
: ['1', '2', '3']

* Basics, Features, Examples

** Types
As with any mainstream language, Python has a lot of types.

To categorize, they can be broken into primitive or built-in types and user-defined 
types (classes).

There are also container types (made up of primitive types). Typically, these 
types have some specific properties that make them special. Containers types can 
be broken down into ordered sequence types (list, tuple, etc.) and key/association types (set, dict).

Details of Pyhon3 types can be found here: https://docs.python.org/3/library/stdtypes.html
High level list can be found here: https://docs.python.org/2/library/types.html

Let's cover primitive types first:

#+BEGIN_SRC python :results output :exports both
a, b, c, d, e, f = 12, int(12), -12, 12.456, float(12.456), 1 * 10**9
print(a, b, c, d, e, f)
# Note that d (1 billion) is also an int
# Python 3 made every number int: https://stackoverflow.com/questions/2104884/how-does-python-manage-int-and-long
print(type(a), type(b), type(c), type(d), type(e), type(f))

g, h, i = "abc", 'abc', str("abc")
print(g, h, i)
print(type(g), type(h), type(i))

j, k = True, bool(False)
print(j, k)
print(type(j), type(k))

l = bytes(123)
print(l)
#+END_SRC

#+RESULTS:
: (12, 12, -12, 12.456, 12.456, 1000000000)
: (<type 'int'>, <type 'int'>, <type 'int'>, <type 'float'>, <type 'float'>, <type 'int'>)
: ('abc', 'abc', 'abc')
: (<type 'str'>, <type 'str'>, <type 'str'>)
: (True, False)
: (<type 'bool'>, <type 'bool'>)
: 123

There are also binary types such as bytes, bytearray, memoryview. Read about these
here: https://www.w3resource.com/python/python-bytes.php

Now let's see some container types:

#+BEGIN_SRC python :results output :exports both
a, b = [1, 2, 3], list([1, 2, 3])
print(a, b)
print(type(a),type(b))

c, d, d1 = (), (1, "2", 3.4), tuple((1, "2", 3.4))
print(c, d, d1)
print(type(c), type(d), type(d1))

e, f = set({1, 2, 3}), {1, 2, 3} # note {} is dict so empty set must be created using set()
print(e, f)
print(type(e), type(f))

g, h = {}, {"a": 2, "b": 6} # dict() usage was complicated for me
print(g, h)
print(type(g), type(h))
#+END_SRC

#+RESULTS:
: ([1, 2, 3], [1, 2, 3])
: (<type 'list'>, <type 'list'>)
: ((), (1, '2', 3.4), (1, '2', 3.4))
: (<type 'tuple'>, <type 'tuple'>, <type 'tuple'>)
: (set([1, 2, 3]), set([1, 2, 3]))
: (<type 'set'>, <type 'set'>)
: ({}, {'a': 2, 'b': 6})
: (<type 'dict'>, <type 'dict'>)
