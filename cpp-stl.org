#+TITLE: C++ Standard Template Library based off [[https://www.youtube.com/playlist?list%3DPL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb][Bo's videos]]

** Introduction
C++ Standard Template Library (STL) is a subset of C++ Standard Library.

STL has [[http://en.cppreference.com/w/cpp/concept/Container][containers]] and [[http://en.cppreference.com/w/cpp/algorithm][algorithms]]:
- The containers contains data structures (implementations of common ADTs). Common containers can be found [[http://en.cppreference.com/w/cpp/container][here]].
- The algorithms contains common algorithms to operate on these containers. Common algorithms can be found [[http://en.cppreference.com/w/cpp/algorithm][here]].

Let's say we have =N= algorithms and =M= containers. With a naive OOP approach, we'll
need =N * M= implementations so that every algorithm operates on every container and
every container can be worked on by every algorithm.

A better approach that C++ STL takes is more of a functional approach. Essentually,
we abstract out the roles of containers and algorithms: containers care about data,
how it's laid out in memory, and what are the common operations clients can perform
on the data. Algorithms only care about the underlying algorithm i.e. sort will just
implement a good sorting algorithm, not caring about what container the client
is going to use it on. 

With this approach, to glue containers and algorithms, we use [[http://en.cppreference.com/w/cpp/concept/Iterator][iterators]]. Iterators
can be thought of as a convience and are essentially an abstract layer or an extra
indirection between containers and algorithms. Iterators can be thought of as pointers
pointing to some element in the container. [[http://en.cppreference.com/w/cpp/iterator][Here]] is a library of iterators in C++.

Now every algorithm will interact with an iterator interface. Similarly, every
container will be written in a way that it implements common iterator API's for
containers to use. This way, we can have =N + M= implementations instead of
=N * M= like before.

** Getting started example

This is a basic example to illustrate containers, iterators, and algorithms:

#+BEGIN_SRC C++ :exports both
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // let's create and populate a  vector container object
    vector<int> vec;
    vec.push_back(4);
    vec.push_back(1);
    vec.push_back(8);
    // now vec is: {4, 1, 8}

    // now let's traverse the elements of this vector
    // note that begin points to first element in container,
    // and
    // end points to the address location *after* the last
    // element
    // so we can't do *vec.end() => undefined behavior
    vector<int>::iterator itr1 = vec.begin();
    vector<int>::iterator itr2 = vec.end();

    for (vector<int>::iterator itr = itr1; itr != itr2;
         ++itr)
        cout << *itr << " "; // Prints "4 1 8"

    sort(itr1, itr2); // Note sort doesn't care about
                      // underlying container... it just
                      // works on iterators.

    // another modern way to traverse the container
    cout << "\n";
    for (const auto e : vec)
      cout << e << " "; // prints sorted "1 4 8"

    return 0;
}
#+END_SRC

#+RESULTS:
| 4 | 1 | 8 |
| 1 | 4 | 8 |

