#+TITLE: C++ Standard Template Library based off [[https://www.youtube.com/playlist?list%3DPL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb][Bo's videos]]

** Introduction
C++ Standard Template Library (STL) is a subset of C++ Standard Library.

STL has [[http://en.cppreference.com/w/cpp/concept/Container][containers]] and [[http://en.cppreference.com/w/cpp/algorithm][algorithms]]:
- The containers contains data structures (implementations of common ADTs). Common containers can be found [[http://en.cppreference.com/w/cpp/container][here]].
- The algorithms contains common algorithms to operate on these containers. Common algorithms can be found [[http://en.cppreference.com/w/cpp/algorithm][here]].

Let's say we have =N= algorithms and =M= containers. With a naive OOP approach, we'll
need =N * M= implementations so that every algorithm operates on every container and
every container can be worked on by every algorithm.

A better approach that C++ STL takes is more of a functional approach. Essentually,
we abstract out the roles of containers and algorithms: containers care about data,
how it's laid out in memory, and what are the common operations clients can perform
on the data. Algorithms only care about the underlying algorithm i.e. sort will just
implement a good sorting algorithm, not caring about what container the client
is going to use it on. 

With this approach, to glue containers and algorithms, we use [[http://en.cppreference.com/w/cpp/concept/Iterator][iterators]]. Iterators
can be thought of as a convience and are essentially an abstract layer or an extra
indirection between containers and algorithms. Iterators can be thought of as pointers
pointing to some element in the container. [[http://en.cppreference.com/w/cpp/iterator][Here]] is a library of iterators in C++.

Now every algorithm will interact with an iterator interface. Similarly, every
container will be written in a way that it implements common iterator API's for
containers to use. This way, we can have =N + M= implementations instead of
=N * M= like before.

*** Getting started example

This is a basic example to illustrate containers, iterators, and algorithms:

#+BEGIN_SRC C++ :exports both
  #include <algorithm>
  #include <iostream>
  #include <vector>

  using namespace std;

  int main() {
      // let's create and populate a  vector container object
      vector<int> vec;
      vec.push_back(4);
      vec.push_back(1);
      vec.push_back(8);
      // now vec is: {4, 1, 8}

      // now let's traverse the elements of this vector
      // note that begin points to first element in container,
      // and
      // end points to the address location *after* the last
      // element
      // so we can't do *vec.end() => undefined behavior
      vector<int>::iterator itr1 = vec.begin();
      vector<int>::iterator itr2 = vec.end();

      for (vector<int>::iterator itr = itr1; itr != itr2;
           ++itr)
          cout << *itr << " "; // Prints "4 1 8"

      sort(itr1, itr2); // Note sort doesn't care about
                        // underlying container... it just
                        // works on iterators.

      // another modern way to traverse the container
      cout << "\n";
      for (const auto e : vec)
        cout << e << " "; // prints sorted "1 4 8"

      return 0;
  }
#+END_SRC

#+RESULTS:
| 4 | 1 | 8 |
| 1 | 4 | 8 |

*** Motivations for using STL
1) Code reuse, no need to reinvent the wheel.
2) Efficiency -- time and space wise. Modern C++ compilers are usually tuned to optimize for C++ standard library code.
3) Accurate, less buggy.
4) Terse, readable code; reduced control flow.
5) Standardization; guaranteed availability.
6) A role model for writing libraries.
7) Enhances data structures and algorithms knowledge.
** Sequence containers
Typically, sequence containers are implemented using array or linked list.
Examples of sequence containers are: 
- vector
- deque
- list
- forward list
- array

Sequence arrays are characterized by their linear mental model. We can think
of them as a sequence of elements growing in one or both ends. The order
of sequence containers is generally the order in which elements were inserted in
them.

*** Vector
Vector is a dynamically allocated (heap) contiguous array in memory. It can be
thought of as a dynamically sized array.

#+BEGIN_SRC C++ :exports both
    vector<int> vec; // vec.size() == 0
    vec.push_back(4);
    vec.push_back(1);
    vec.push_back(8); // vec: {4, 1, 8}; vec.size() == 3

    // Vector specific operations
    // Random access is O(1)
    cout << vec[2];    // 8 (no range check)
    cout << vec.at(2); // 8 (throws range_error exception if
                       // out of range)

    // Traversing vector elements
    for (int i; i < vec.size(); ++i)
        cout << vec[i] << " ";

    // Another traversal way is through iterators
    // Preferred because:
    // 1) faster
    // 2) canonical/standard way of traversal e.g. can
    // replace vector with list
    for (vector<int>::iterator itr = vec.begin();
         itr != vector.end(); ++itr)
        cout << *itr << " ";

    // C++ 11 way
    for (auto e : vec)
        cout << e << " ";

    // Can exploit contiguous memory invariant
    int* p = &vec[0];
#+END_SRC

Pros: 
- Random access is O(1)
- Insert/remove at end of vector is O(1)
- Invariant: contiguous memory => better cache locality.

Cons:
- Searching is O(n)
- Inserting/removing element in start or middle is O(n) since we'll have to move other elements around to manintain contiguous memory invariant.

*** Common contain interfaces
Using vector as an example:
#+BEGIN_SRC C++ :exports both
    // Common member functions of all containers.
    // vec: {4, 1, 8}

    if (vec.empty())
        cout << "empty\n";

    cout << vec.size() << "\n";

    // Copy constructor, vec2: {4, 1, 8}
    vector<int> vec2(vec);

    // Remove all items in vec; vec.size() == 0
    vec.clear();

    // swap; in this case vec2 becomes empty and vec has 3
    // items
    vec2.swap(vec);

    // No penality of abstraction, very efficient.
#+END_SRC

*** Deque
Deque is like a vector but can grow on both sides, back and front.

#+BEGIN_SRC C++ :exports both
    deque<int> deq = {4, 6, 7};
    deq.push_front(2); // deq: {2, 4, 6, 7}
    deq.push_back(3);  // deq: {2, 4, 6, 7, 3}

    // Deque has similar interface like vector
    cout << deq[1]; // 4
#+END_SRC

Pros:
- Although deque isn't implemented like a vector to maintain a contiguous memory invariant, it still provides O(1) random access.
- Can grow from front and back; better for some use cases.
- Insert/remove at front and end is O(1)

Cons:
- No contiguous memory invariant => not as cache optimized as vector.
- Insert/remove in middle is O(n)
- Search is slow: O(n)
*** List
List is a doubly linked list i.e. every element/node has pointer to its next
element and previous element.

#+BEGIN_SRC C++ :exports both
    list<int> my_list = {5, 2, 9};
    my_list.push_back(6);  // my_list: {5, 2, 9, 6}
    my_list.push_front(4); // my_list: {4, 5, 2, 9, 6}

    // itr -> 2 after this
    list<int>::iterator itr =
        find(my_list.begin(), my_list.end(), 2);

    // to insert, we need to give an iterator and item to
    // insert
    // this is how we get O(1) insert in middle
    // itr must be provied otherwise we don't know after
    // what element
    // to add the item.
    my_list.insert(itr, 8); // my_list: {4, 5, 8, 2, 9, 6}

    itr++; // itr -> 9

    // remove element from middle is also O(1)
    my_list.erase(itr); // my_list: {4, 8, 5, 2, 6}
#+END_SRC

Pros:
- O(1) insert/remove at any position: front, middle, or back.
- splice! See below.

Cons:
- Not as space efficient; requires extra memory for pointers
- Not contiguous in memory => not as cache optimized
- Search is O(n) even slower than vector because of cache locality (see above).
- No random access i.e. no [] operator

#+BEGIN_SRC C++ :exports both
    // O(1) operation
    // Splice
    // Cut my_list2 from itr_a to itr_b, and connect it
    // to my_list at position itr!
    my_list.splice(itr, my_list2, itr_a, itr_b);
#+END_SRC

*** Forward list
Singly linked list. Similar to list above but only has uni directional
functionality.

*** Array
Raw arrays like "int a[3] = {3, 4, 5}" can't use the common container
interface. STL provides std::array which is a thin layer around raw array.

#+BEGIN_SRC C++ :exports both
    int a[3] = {3, 4, 5};

    array<int, 3> a = {3, 4, 5};

    // Now can use:
    a.begin();
    a.end();
    a.size();
    a.swap();
#+END_SRC

Pros:
- Contiguous memory => better cache locality.
- Can use container interface methods like size and swap.

Cons:
- Fixed size
- Type is defined as <element_type, array_size> pair i.e. array<int, 2> and array<int, 3> are different types; we can pass one to a function when the function expects another.


** Associative containers
Typically, associative containers are implemented using binary trees.
Examples of associative containers are:

- set and multiset
- map and multimap

Associative containers are characterized by their associative model i.e.
we have keys which map/associate to values. In some cases, keys are values e.g.
in set. But associative term comes from map.

The order of associative containers is the sorted order. Clients can provide
their own sorting criteria but by default it's ascending order. So, the
property of associative containers is that they are always sorted.

Pros:
- always sorted, default criteria is <

Cons:
- No push_back(), push_front()

*** Set
Set is just a collection of keys. If you iterate over a set, the keys will
be visited in sorted order.

Set does not have any duplicate keys.

#+BEGIN_SRC C++ :exports both
    set<int> myset;
    // insert always take O(log(n)) time
    myset.insert(3); // myset: {3}
    myset.insert(1); // myset: {1, 3}
    myset.insert(7); // myset: {1, 3, 7}

    set<int>::iterator it;
    it = myset.find(7); // O(log(n)), it points to 7

    // insert returns a pair
    // pair.first is the iterator to the element of inserted
    // item
    // pair.second is a boolean indicating whether the
    // element was inserted or not.. it's false if the
    // element was already there.. remember set has no
    // duplicates
    // in the example below, insert will return false
    pair<set<int>::iterator, bool> ret = myset.insert(3);

    if (!ret.second)
        it = ret.first; // "it" now points to element 3

    myset.insert(it, 9); // myset: {1, 3, 7, 9}
    // Interestingly, why are we passing "it" to set.insert
    // when we know that order of this container is not
    // order of
    // insertion, it's based on sorting.
    // Note that 9 was inserted at end here, not after 3.
    // The reason why we provide iterator is because we can
    // give a
    // "hint" to find the location where 9 has to be
    // inserted.
    // A "good hint" can result in O(1) time but in general,
    // insertion is O(log(n))

    // erase by position: O(1)
    myset.erase(it); // myset: {1, 7, 9}

    // erase by value (key) -- can do it because value
    // always unique
    // since there are no duplicates in set.
    // this erasure is O(log(n))
    myset.erase(7); // mset: {1, 9}
#+END_SRC

Pros:
- Search is O(log(n))
- Can erase by key value in O(log(n)) because of search (above).

Cons:
- Insertion is O(log(n))
- Read only values: Key value can not be modified given the iterator. This is because doing so will invalidate the set internal tree representation which maintains the sorting invariant (see multiset below for example).
- No random access i.e. [] operator
- Traversing is slow (compared to vector) because of cache locality

*** Multiset

Similar to set but allows duplicates.

*** Map
Sometimes we want to sort according to key, not value like set. Note that in the 
set, we use key and value interchangeably. For this, we can use a map.

Map is similar to set except that we have <key, value> pairs intead of just values.
Sorting is then done by key.

Map and multimap have similar interface like set and multiset.

#+BEGIN_SRC C++ :exports both
    // map doesn't allowed duplicate keys
    map<char, int> mymap;
    // insert in O(log(n))
    mymap.insert(pair<char, int>('a', 100));
    // insert can be done using make_pair helper
    // make_pair infers type
    mymap.insert(make_pair('z', 200));

    map<char, int>::iterator it = mymap.begin();
    mymap.insert(
        it, pair<char, int>('b', 300)); // "it" is a hint

    it = mymap.find('z'); // O(log(n))

    // traversing
    for (it = mymap.begin(); it != mymap.end(); ++it)
        cout << (*it).first << " -> " << (*it).second
             << endl;
#+END_SRC

*** Multimap

Just like map but can have duplicate keys.

#+BEGIN_SRC C++ :exports both
    multimap<char, int> mymap;

    // map/multimap:
    // keys can not be modified because otherwise we will
    // invalidate the internal data structure sorting
    // invariant
    // type of *it: pair<const char, int>
    // notice the "const"
    (*it).first = 'd'; // error
#+END_SRC
