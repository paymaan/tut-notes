#+TITLE: Haskell notes based on [[http://learnyouahaskell.com][Learn You A Haskell For Great Good]]

* Setup
See [[http://learnyouahaskell.com/introduction#what-you-need][What you need to dive in]].

These notes will be in [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style. All code will be compiled and executed using [[https://www.haskell.org/ghc/][GHC]].

* Basics
** Numbers, strings, booleans, and expressions
*Simple arithmetic*

#+BEGIN_SRC haskell :exports both :exports both
  5 + 2
#+END_SRC

#+RESULTS:
: 7

#+BEGIN_SRC haskell :exports both
  10 + 14.5
#+END_SRC

#+RESULTS:
: 24.5

Default type for numbers is floating point:
#+BEGIN_SRC haskell :exports both
  7 / 2
#+END_SRC

#+RESULTS:
: 3.5

Be careful with negative numbers:
#+BEGIN_SRC haskell :exports both
  5 * -2
#+END_SRC

#+RESULTS:
: <interactive>:10:1:
:     Precedence parsing error
:         cannot mix `*' [infixl 7] and prefix `-' [infixl 6] in the same infix expression

Better to surround negative numbers with parens:
#+BEGIN_SRC haskell :exports both
  5 * (-2)
#+END_SRC

#+RESULTS:
: -10

*Parens*

Alright, parens are important to explicitly tell the compiler your precendence:
#+BEGIN_SRC haskell :exports both
  50 * (100 - 4999)
#+END_SRC

#+RESULTS:
: -244950

Otherwise, regular operator precedence rules will apply:
#+BEGIN_SRC haskell :exports both
  50 * 100 - 4999
#+END_SRC

#+RESULTS:
: 1

*Boolean algebra*

Let's look at these keywords and operators: =TRUE=, =FALSE=, =not=, logical AND =&&=, logical OR =||=
#+BEGIN_SRC haskell :exports both
  True && False
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC haskell :exports both
  True && True
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  False || True
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  not False
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  not (True && True)
#+END_SRC

#+RESULTS:
: False

*Equality operators*

#+BEGIN_SRC haskell :exports both
  9 == 9
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  9 == 8
#+END_SRC

#+RESULTS:
: False

=/= means /not/ in the context of equality operators:
#+BEGIN_SRC haskell :exports both
  9 /= 9
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC haskell :exports both
  9 /= 8
#+END_SRC

#+RESULTS:
: True

We can compare strings as well:
#+BEGIN_SRC haskell :exports both
  "yo" == "yo"
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  "yo" == "no"
#+END_SRC

#+RESULTS:
: False

** Functions
Syntax for functions:

#+BEGIN_SRC haskell :exports both
  min 8 9
#+END_SRC

#+RESULTS:
: 8

So it's the function name followed by input arguments. Another example:

#+BEGIN_SRC haskell :exports both
  succ 19
#+END_SRC

#+RESULTS:
: 20

Calling a function takes highest precedence:

#+BEGIN_SRC haskell :exports both
  succ 5 + max 2 3 + 1
#+END_SRC

#+RESULTS:
: 10

The above is equivalent to:

#+BEGIN_SRC haskell :exports both
  (succ 5) + (max 2 3) + 1
#+END_SRC

#+RESULTS:
: 10

Above functions are of type =prefix= i.e. function name comes before the arguments. 
Another syntax for writing functions in haskell is =infix=:

#+BEGIN_SRC haskell :exports both
  5 * 4
#+END_SRC

#+RESULTS:
: 20

Wait, =*= is an operator, right? Everything in haskell is a function, even operators.
Anyways, =infix= means the name is at the center of the two arguments. Yes, =infix= is
only valid for 2 arguments. 

Any function that takes two arguments can always be represented using =infix= syntax:

#+BEGIN_SRC haskell :exports both
  87 `div` 10
#+END_SRC

#+RESULTS:
: 8

Okay, that's how functions are called. They are defined in a similar way:

#+BEGIN_SRC haskell :exports both
  let doubleUs x y = x*2 + y*2
  doubleUs 1 2
#+END_SRC

#+RESULTS:
: 6

The =let= here is just to provide the definition to the haskell interpreter. If we had a script that we were
compiling, we won't need that. To load that script though, we'd need to say =:l funcName=

So we saw the syntax is function name followed by input arguments followed by
= followed by an expression that calculates the output.

Haskell functions are pure, more about that later.

Haskell functions also can not begin with a capital letter. We'll see why later.

** Conditionals

Alright, this is how we write conditionals:

#+BEGIN_SRC haskell :exports both
  let doubleSmallNumber x = if x > 100 then x else 2*x
  doubleSmallNumber 40
#+END_SRC

#+RESULTS:
: 80

#+BEGIN_SRC haskell :exports both
  doubleSmallNumber 500
#+END_SRC

#+RESULTS:
: 500

Note that conditionals /always/ need an else. This is because in haskell, an if statement is an
expression meaning that it has to return a value, or in other words, evaluate to something.

** Lists
Lists in haskell are actually implemented as singly linked lists. Infact, they are as simple as:

#+BEGIN_SRC haskell :exports code
  data MyList a = Nil | Cons a (MyList a)
#+END_SRC

Haskell has a lot of tricks in its bag when it comes to list manipulation. Also, because of laziness, lists
are used as iterators and they give /acceptable/ performance. Examples later would help demonstrate this.

Lists is a =homogenous= data structure in haskell i.e. it only stores elements of the same type.

As an example, String in haskell is just a list of characters.

There are many commands in this section, so let's just look at code and hopefully that should be self-explanatory:

#+BEGIN_SRC haskell :exports both
  let myList = [4,77,17,23,55]
  myList
#+END_SRC

#+RESULTS:
| 4 | 77 | 17 | 23 | 55 |

#+BEGIN_SRC haskell :exports both
  myList ++ [1,2,3]
#+END_SRC

#+RESULTS:
| 4 | 77 | 17 | 23 | 55 | 1 | 2 | 3 | 

#+BEGIN_SRC haskell :exports both
  99 : myList
#+END_SRC  

#+RESULTS:
| 99 | 4 | 77 | 17 | 23 | 55 |

#+BEGIN_SRC haskell :exports both
  'C' : "AN JOIN BECAUSE STRINGS ARE LIST OF CHARS!"
#+END_SRC  

#+RESULTS:
: CAN JOIN BECAUSE STRINGS ARE LIST OF CHARS!

#+BEGIN_SRC haskell :exports both
  myList !! 3
#+END_SRC  

#+RESULTS:
: 23

#+BEGIN_SRC haskell :exports both
  head [1,2,3]
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC haskell :exports both
  tail [1,2,3]
#+END_SRC

#+RESULTS:
| 2 | 3 |

#+BEGIN_SRC haskell :exports both
  init [1,2,3]
#+END_SRC

#+RESULTS:
| 1 | 2 |

#+BEGIN_SRC haskell :exports both
  last [1,2,3]
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC haskell :exports both
  null [1,2,3]
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC haskell :exports both
  reverse [1,2,3]
#+END_SRC

#+RESULTS:
| 3 | 2 | 1 |

*** List Ranges

Again, let's go through some code which should be self-explanatory:

#+BEGIN_SRC haskell :exports both
  [1..10]
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

#+BEGIN_SRC haskell :exports both
  [1,2..10]
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

#+BEGIN_SRC haskell :exports both
  [10,9..1]
#+END_SRC

#+RESULTS:
| 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |

#+BEGIN_SRC haskell :exports both
  [1,3..10]
#+END_SRC

#+RESULTS:
| 1 | 3 | 5 | 7 | 9 |

#+BEGIN_SRC haskell :exports both
  [2,4..20]
#+END_SRC

#+RESULTS:
| 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |

Floating point stepping can be funky, so better not go there:
#+BEGIN_SRC haskell :exports both
  [0.1,0.3..1]
#+END_SRC

#+RESULTS:
| 0.1 | 0.3 | 0.5 | 0.7 | 0.8999999999999999 | 1.0999999999999999 |

#+BEGIN_SRC haskell :exports both
  ['a'..'z']
#+END_SRC

#+RESULTS:
: abcdefghijklmnopqrstuvwxyz

You can also step by 2 letters (pretty cool, 'an?):

#+BEGIN_SRC haskell :exports both
  ['a','c'..'z']
#+END_SRC

#+RESULTS:
: acegikmoqsuwy

#+BEGIN_SRC haskell :exports both
  ['S'..'Z']
#+END_SRC

#+RESULTS:
: STUVWXYZ

#+BEGIN_SRC haskell :exports both
  [13,26..7*13]
#+END_SRC

#+RESULTS:
| 13 | 26 | 39 | 52 | 65 | 78 | 91 | 

Another way using =take= function:

#+BEGIN_SRC haskell :exports both
  take 7 [13,26..]
#+END_SRC

#+RESULTS:
| 13 | 26 | 39 | 52 | 65 | 78 | 91 |

Wait, we can have infinite lists !? Well, yes:

#+BEGIN_SRC haskell :exports code
  [1,2,..]
#+END_SRC

But don't try to execute it. Haskell is lazy but once we try to evaluate this expression, it'll
want to calculate all numbers to infinity. That takes /infinite/ time then, which clearly we don't have.
The earlier example worked because =take= took /7/ as an argument so haskell knows we need only /7/
elements of the infinite list, atleast for now. This is why laziness is really powerful!

#+BEGIN_SRC haskell :exports both
  take 10 (cycle [1,2,3])
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 1 | 2 | 3 | 1 | 2 | 3 | 1 |

=cycle= function just repeats the list to produce an infinite list. This example worked
because we used the =take= function again, which tells haskell we only need 10 elements of
this infinite list.

Similar to =cycle= function is =repeat= which is like =cycle= but with one element only:

#+BEGIN_SRC haskell :exports both
  take 10 (repeat 5)
#+END_SRC

#+RESULTS:
| 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |

Can also use =replicate=:

#+BEGIN_SRC haskell :exports both
  replicate 3 10
#+END_SRC

#+RESULTS:
| 10 | 10 | 10 |

*** List Comprehensions

List comprehensions are one of the reasons haskell has concise and expressive syntax. 

List comprehensions are very similar to [[https://en.wikipedia.org/wiki/Set-builder_notation][Set Comprehensions]] in math.

List comprehensions essentially are used to form a subset of a list from a another list by
operations and filters.

Let's look at a list comprehension:

#+BEGIN_SRC haskell :exports both
  [x*2 | x <- [1..10]]
#+END_SRC

#+RESULTS:
| 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |

This is how the above code expression would read:
=x= is drawn from the list =[1..10]= and for /every/ element in this list, multiply
it by 2 or =x*2=. The final result is a list again.

Note that in haskell, =x <- [1..10]= means =[1..10]= is bound to =x=.

Let's go one step further; we can apply filters or predicates:

#+BEGIN_SRC haskell :exports both
  [x*2 | x <- [1..10], x*2 > 13]
#+END_SRC

#+RESULTS:
| 14 | 16 | 18 | 20 |

This now says the same thing as before, but now, after the result is evaulated,
we filter them using the =x*2 > 13= predicate before the list is finalized. 

We can also have multiple predicates:

#+BEGIN_SRC haskell :exports both
  [x*2 | x <- [1..10], x*2 > 13, x*2 < 17]
#+END_SRC

#+RESULTS:
| 14 | 16 |

Note that the two predicates here have an /and/ relationship i.e. both must be met
before the elements can go into the final list.

We can draw from multiple lists as well:

#+BEGIN_SRC haskell :exports both
  [x*y | x <- [2,5,10], y <- [8,10,11]]
#+END_SRC

#+RESULTS:
| 16 | 20 | 22 | 40 | 50 | 55 | 80 | 100 | 110 | 

Without filters, the length is =3*3= or =9= as expected.
Let's apply a filter now:

#+BEGIN_SRC haskell :exports both
  [x*y | x <- [2,5,10], y <- [8,10,11], x*y>50]
#+END_SRC

#+RESULTS:
| 55 | 80 | 100 | 110 |

** Tuples

At first tuples may seem like lists, but there are two keys differences:
1) Lists are homogenous i.e. all elements have to have the same type e.g. integer. Tuples on the other hand can have elements of different types.
2) The type of a list is defined only by the type of its elements i.e. =[1,2,3]= is a list of ints. For tuples, however, the type is defined not only by the types of its elements but also by the /number/ of elements i.e. a tuple with 2 ints is different from a tuple with 3 ints which is different from a tuple with 2 ints and 1 string.

Let's take a look at a simple example:

#+BEGIN_SRC haskell :exports both
  (1,3,"string",'c',5.09)
#+END_SRC

#+RESULTS:
| 1 | 3 | string | c | 5.09 |

A tuple with 2 elements is called a /pair/:

#+BEGIN_SRC haskell :exports both
  (8,11)
#+END_SRC

#+RESULTS:
| 8 | 11 |

Haskell has functions just for pairs:

#+BEGIN_SRC haskell :exports both
  fst (8,11)
#+END_SRC

#+RESULTS:
: 8

#+BEGIN_SRC haskell :exports both
  snd (8,11)
#+END_SRC

#+RESULTS:
: 11

By extension, tuples with 3 elements are called /triplets/. After that, they are called
/4-tuples/, /5-tuples/ etc.

Tuples are more rigid; think of how we can make a list of 2-D vectors. One way is:

#+BEGIN_SRC haskell :exports both
  [ [1,2], [8,11], [4,5] ]
#+END_SRC

#+RESULTS:
| 1 |  2 |
| 8 | 11 |
| 4 |  5 | 

Well, this sort of works but now someone can do:

#+BEGIN_SRC haskell :exports both
  [ [1,2], [8,11,15], [4,5] ]
#+END_SRC

#+RESULTS:
| 1 |  2 |    |
| 8 | 11 | 15 |
| 4 |  5 |    |

This works but shouldn't. Answer is unsurprisingly, tuples:

#+BEGIN_SRC haskell :exports both
  [ (1,2), (8,11), (4,5) ]
#+END_SRC

#+RESULTS:
| 1 |  2 |
| 8 | 11 |
| 4 |  5 | 

Now no one can do:

#+BEGIN_SRC haskell :exports both
  [ (1,2), (8,11,15), (4,5) ]
#+END_SRC

#+RESULTS:
: <interactive>:34:10:
:     Couldn't match expected type `(t, t1)'
:                 with actual type `(Integer, Integer, Integer)'
:     Relevant bindings include
:       it :: [(t, t1)] (bound at <interactive>:34:1)
:     In the expression: (8, 11, 15)
:     In the expression: [(1, 2), (8, 11, 15), (4, 5)]
:     In an equation for `it': it = [(1, 2), (8, 11, 15), (4, 5)]

Heck, they can't even do this:

#+BEGIN_SRC haskell :exports both
  [ (1,2), (8,11), ("four",5) ]
#+END_SRC

#+RESULTS:
: <interactive>:36:4:
:     Could not deduce (Num [Char]) arising from the literal `1'
:     from the context (Num t)
:       bound by the inferred type of it :: Num t => [([Char], t)]
:       at <interactive>:36:1-29
:     In the expression: 1
:     In the expression: (1, 2)
:     In the expression: [(1, 2), (8, 11), ("four", 5)]

This is because, as discussed earlier, type of tuples encodes both
the type of all of its elements as well as the total number of elements.

Finally, let's look at the very useful, =zip= function:

#+BEGIN_SRC haskell :exports both
  zip [1..5] ['a'..'e']
#+END_SRC

#+RESULTS:
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |
| 5 | e |

As we see, it takes in two lists, and stiches them element-by-element forming a list of pairs.
Note that if the lists have different lengths, it picks the minimum of the lengths:

#+BEGIN_SRC haskell :exports both
  zip [1..3] ['a'..'e']
#+END_SRC

#+RESULTS:
| 1 | a |
| 2 | b |
| 3 | c | 

* Types and Typeclasses

Haskell has a static type system which means that when you compile your haskell code, the compiler will try to
know types of /all/ expressions in the code. If all types can't be found, the compiler will error out. Then the
question comes up on how Haskell calculates what type you are using. In some cases, the code explicitly states
the types e.g. in a function declaration. In other cases, Haskell tries to infer or deduce the type based on the 
context. For example, when the compiler sees ~let a = 'p'~, it deduces the type of =a= is =char=. In general, Haskell
uses an extension of [[https://en.wikipedia.org/wiki/Type_inference#Hindley.E2.80.93Milner_type_inference_algorithm][Hindley-Milner-style]] type inference.

Alright, now how do we ask Haskell what's the type it has calculated? Here's how:

#+BEGIN_SRC haskell
  Prelude> :t 'a'
  'a' :: Char

  Prelude> :t "a"
  "a" :: [Char]

  Prelude> :t "HELLO"
  "HELLO" :: [Char]

  Prelude> :t (True, 'a')
  (True, 'a') :: (Bool, Char)

  Prelude> :t (1, 'a')
  (1, 'a') :: Num t => (t, Char)

  Prelude> :t 4 == 5
  4 == 5 :: Bool
#+END_SRC

So, when we say ~:t expression~, Haskell gives us the result in the format ~expression :: type~.

Let's try this on functions (~[Int] -> Int~ is called a =function declaration= where we explicitly state the function type):

#+BEGIN_SRC haskell :exports both
  let getListHead :: [Int] -> Int; getListHead list = list !! 0
  :t getListHead
#+END_SRC

#+RESULTS:
: getListHead :: [Int] -> Int

By the way, remember that Haskell is lazy? So we can actually get the head of an infinite list:
#+BEGIN_SRC haskell :exports both
  let getListHead :: [Int] -> Int; getListHead list = list !! 0
  getListHead [1,2..]
#+END_SRC

#+RESULTS:
: 1

Alright, back to types. What if we don't provide an explicit type declaration and let Haskell decide the type of the function:
#+BEGIN_SRC haskell :exports both
  let getListHead list = list !! 0
  :t getListHead
#+END_SRC

#+RESULTS:
: getListHead :: [a] -> a

Now what's =a=? It's not a type because types always start with upper case letters in Haskell.
It's actually a /type variable/. It signifies that =a= can be of /any/ type. This is like /generics/ in other languages.
Functions that have /type variables/ in their types are called /polymorphic/ functions in Haskell.

Let's see the type of another pre-defined function in Haskell:
#+BEGIN_SRC haskell :exports both
  :t fst
#+END_SRC

#+RESULTS:
: fst :: (a, b) -> a

This says that the =fst= function takes in a pair of type ~(a,b)~ where ~a~ and ~b~ can be of any type themselves. The function
then returns a value of type ~a~. This makes sense since the =fst= function returns the first element of a pair.

Note that ~a~ and ~b~ /can/ be the same type. This is just like variables. Two variables can have the same value.

** Typeclasses
Let's keep moving. What if we do:

#+BEGIN_SRC haskell :exports both
  :t (==)
#+END_SRC

#+RESULTS:
: (==) :: Eq a => a -> a -> Bool

Wait, what? What's ~=>~ now? What's =Eq=? Let's back up a little, isn't ~==~ an operator? No, remember in Haskell operators
are actually functions? We can call them whatever we want; the important thing is that operators in Haskell are no different
than other functions since they /are/ functions and are /implemented/ as such in the language.

Alright, so we were taking the type of a function. We can parse the part ~a -> a -> Bool~ atleast. This says that the
function takes in two input arguments of the /same/ type =a=, which itself can be of /any/ type. The function then
returns a value of type =Bool=.

Good, what's =Eq= now? It's a /typeclass/.

Typeclasses are like abstract classes in C++ that provide an interface. When we derive from the abstract class, we
are saying that the derived/child class is a kind of the abstract class. For example, an abstract class can be
=Fruit=. Although that's just an interface which we can't instantiate in C++. We can derive from this class though,
to create =Apple=, =Orange=, =Banana= etc. All these classes are now concrete classes that we can instantiate. Finally,
we can create instances of these classes. Like we can have 2 apples, 3 oranges, and 1 banana. We do this by making
/objects/ of that class in C++.

So how can we compare the above with /Typeclasses/, /types/, and /values/? Well, /Typeclasses/ are like interface, /types/ are
like concrete derived classes of that interface, and /values/ are instances/objects of the derived classes.

What's the motivation behind having Typeclasses? Well, if a type is part of a typeclass, that means that it supports
and implements the behavior of the typeclass it describes.

What's ~=>~ then? It means /class constraint/, which by the way we can have more than one seperated by commas.
So in addition ~a -> a -> Bool~, we are also saying that /type variable/
=a= now can not be of /any/ type, but now it /must/ be of a type that is of typeclass =Eq=. All of this information
is encapsulated in ~(==) :: Eq a => a -> a -> Bool~.

=Eq= typeclass provides an interface for testing for equality. Most types in Haskell are part of =Eq= typeclass because in general, we should
be able to compare values of those types. By the way, types can part of multiple typeclasses as well.

Let's look at the type of a very useful function in Haskell, =fromIntegral=:

#+BEGIN_SRC haskell :exports both
  :t fromIntegral
#+END_SRC

#+RESULTS:
: fromIntegral :: (Integral a, Num b) => a -> b

This says that the =fromIntegral= function takes in one input argument of type variable =a= and returns a value of type variable
=b=. =b= can be of /any/ type. However, =a= type variable is restricted. =a= /must/ to be of =Integral= /and/ =Num= typeclasses.
This function is useful because it takes an [[https://www.google.com/url?sa%3Dt&rct%3Dj&q%3D&esrc%3Ds&source%3Dweb&cd%3D2&cad%3Drja&uact%3D8&ved%3D0ahUKEwiWjLvWjL7SAhVr44MKHeWtB88QFggeMAE&url%3Dhttps%253A%252F%252Fwww.quora.com%252FWhat-are-integral-types-in-C%252B%252B&usg%3DAFQjCNFMXvU-0l9jCalXPY1WSD_ssJS9UQ&sig2%3DS5LfdchU9i0oPZUPhIDRyw][integral]] typed input argument and returns a more generic =Num= typed value.

** Type annotations
We can explicitly tell Haskell what type to use by using ~::~ as follows:

#+BEGIN_SRC haskell
Prelude> let myFunction x = 2*x
Prelude> :t myFunction
myFunction :: Num a => a -> a
Prelude> let myFunction2 :: Int -> Int; myFunction2 x = 2*x
Prelude> :t myFunction2
myFunction2 :: Int -> Int
Prelude> let myVar = 5
Prelude> :t myVar
myVar :: Num a => a
Prelude> let myVar2 :: Int; myVar2 = 5
Prelude> :t myVar2
myVar2 :: Int
Prelude> :t read
read :: Read a => String -> a
Prelude> read "5"
*** Exception: Prelude.read: no parse
Prelude> read "5" :: Int
5
Prelude> read "5" :: Float
5.0
Prelude> (read "5" :: Float) * 4
20.0
Prelude> read "(3,'a')"
*** Exception: Prelude.read: no parse
Prelude> read "(3,'a')" :: (Int,Char)
(3,'a')
#+END_SRC

Sidenote: Variables in Haskell are just functions with no input arguments!

** List of types and typeclasses in Haskell
See this [[http://learnyouahaskell.com/types-and-typeclasses][link]] for a summary of different types and typeclasses in Haskell.

