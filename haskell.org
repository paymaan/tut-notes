#+TITLE: Haskell notes based on [[http://learnyouahaskell.com][Learn You A Haskell For Great Good]]

* Setup
See [[http://learnyouahaskell.com/introduction#what-you-need][What you need to dive in]].

These notes will be in [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style. All code will be compiled and executed using [[https://www.haskell.org/ghc/][GHC]].

* Basics
** Numbers, strings, booleans, and expressions
*Simple arithmetic*

#+BEGIN_SRC haskell :exports both :exports both
  5 + 2
#+END_SRC

#+RESULTS:
: 7

#+BEGIN_SRC haskell :exports both
  10 + 14.5
#+END_SRC

#+RESULTS:
: 24.5

Default type for numbers is floating point:
#+BEGIN_SRC haskell :exports both
  7 / 2
#+END_SRC

#+RESULTS:
: 3.5

Be careful with negative numbers:
#+BEGIN_SRC haskell :exports both
  5 * -2
#+END_SRC

#+RESULTS:
: <interactive>:10:1:
:     Precedence parsing error
:         cannot mix `*' [infixl 7] and prefix `-' [infixl 6] in the same infix expression

Better to surround negative numbers with parens:
#+BEGIN_SRC haskell :exports both
  5 * (-2)
#+END_SRC

#+RESULTS:
: -10

*Parens*

Alright, parens are important to explicitly tell the compiler your precendence:
#+BEGIN_SRC haskell :exports both
  50 * (100 - 4999)
#+END_SRC

#+RESULTS:
: -244950

Otherwise, regular operator precedence rules will apply:
#+BEGIN_SRC haskell :exports both
  50 * 100 - 4999
#+END_SRC

#+RESULTS:
: 1

*Boolean algebra*

Let's look at these keywords and operators: =TRUE=, =FALSE=, =not=, logical AND =&&=, logical OR =||=
#+BEGIN_SRC haskell :exports both
  True && False
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC haskell :exports both
  True && True
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  False || True
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  not False
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  not (True && True)
#+END_SRC

#+RESULTS:
: False

*Equality operators*

#+BEGIN_SRC haskell :exports both
  9 == 9
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  9 == 8
#+END_SRC

#+RESULTS:
: False

=/= means /not/ in the context of equality operators:
#+BEGIN_SRC haskell :exports both
  9 /= 9
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC haskell :exports both
  9 /= 8
#+END_SRC

#+RESULTS:
: True

We can compare strings as well:
#+BEGIN_SRC haskell :exports both
  "yo" == "yo"
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  "yo" == "no"
#+END_SRC

#+RESULTS:
: False

** Functions
Syntax for functions:

#+BEGIN_SRC haskell :exports both
  min 8 9
#+END_SRC

#+RESULTS:
: 8

So it's the function name followed by input arguments. Another example:

#+BEGIN_SRC haskell :exports both
  succ 19
#+END_SRC

#+RESULTS:
: 20

Calling a function takes highest precedence:

#+BEGIN_SRC haskell :exports both
  succ 5 + max 2 3 + 1
#+END_SRC

#+RESULTS:
: 10

The above is equivalent to:

#+BEGIN_SRC haskell :exports both
  (succ 5) + (max 2 3) + 1
#+END_SRC

#+RESULTS:
: 10

Above functions are of type =prefix= i.e. function name comes before the arguments. 
Another syntax for writing functions in haskell is =infix=:

#+BEGIN_SRC haskell :exports both
  5 * 4
#+END_SRC

#+RESULTS:
: 20

Wait, =*= is an operator, right? Everything in haskell is a function, even operators.
Anyways, =infix= means the name is at the center of the two arguments. Yes, =infix= is
only valid for 2 arguments. 

Any function that takes two arguments can always be represented using =infix= syntax:

#+BEGIN_SRC haskell :exports both
  87 `div` 10
#+END_SRC

#+RESULTS:
: 8

Okay, that's how functions are called. They are defined in a similar way:

#+BEGIN_SRC haskell :exports both
  let doubleUs x y = x*2 + y*2
  doubleUs 1 2
#+END_SRC

#+RESULTS:
: 6

The =let= here is just to provide the definition to the haskell interpreter. If we had a script that we were
compiling, we won't need that. To load that script though, we'd need to say =:l funcName=

So we saw the syntax is function name followed by input arguments followed by
= followed by an expression that calculates the output.

Haskell functions are pure, more about that later.

Haskell functions also can not begin with a capital letter. We'll see why later.

** Conditionals

Alright, this is how we write conditionals:

#+BEGIN_SRC haskell :exports both
  let doubleSmallNumber x = if x > 100 then x else 2*x
  doubleSmallNumber 40
#+END_SRC

#+RESULTS:
: 80

#+BEGIN_SRC haskell :exports both
  doubleSmallNumber 40
#+END_SRC

#+RESULTS:
: 80

Note that conditionals /always/ need an else. This is because in haskell, an if statement is an
expression meaning that it has to return a value, or in other words, evaluate to something.

** Lists
** Ranges
** Comprehensions
** Tuples
   
