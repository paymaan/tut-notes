#+TITLE: Haskell notes based on [[http://learnyouahaskell.com][Learn You A Haskell For Great Good]]

* Setup
See [[http://learnyouahaskell.com/introduction#what-you-need][What you need to dive in]].

These notes will be in [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style. All code will be compiled and executed using [[https://www.haskell.org/ghc/][GHC]].

* Basics
** Numbers, strings, booleans, and expressions
*Simple arithmetic*

#+BEGIN_SRC haskell :exports both :exports both
  5 + 2
#+END_SRC

#+RESULTS:
: 7

#+BEGIN_SRC haskell :exports both
  10 + 14.5
#+END_SRC

#+RESULTS:
: 24.5

Default type for numbers is floating point:
#+BEGIN_SRC haskell :exports both
  7 / 2
#+END_SRC

#+RESULTS:
: 3.5

Be careful with negative numbers:
#+BEGIN_SRC haskell :exports both
  5 * -2
#+END_SRC

#+RESULTS:
: <interactive>:10:1:
:     Precedence parsing error
:         cannot mix `*' [infixl 7] and prefix `-' [infixl 6] in the same infix expression

Better to surround negative numbers with parens:
#+BEGIN_SRC haskell :exports both
  5 * (-2)
#+END_SRC

#+RESULTS:
: -10

*Parens*

Alright, parens are important to explicitly tell the compiler your precendence:
#+BEGIN_SRC haskell :exports both
  50 * (100 - 4999)
#+END_SRC

#+RESULTS:
: -244950

Otherwise, regular operator precedence rules will apply:
#+BEGIN_SRC haskell :exports both
  50 * 100 - 4999
#+END_SRC

#+RESULTS:
: 1

*Boolean algebra*

Let's look at these keywords and operators: =TRUE=, =FALSE=, =not=, logical AND =&&=, logical OR =||=
#+BEGIN_SRC haskell :exports both
  True && False
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC haskell :exports both
  True && True
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  False || True
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  not False
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  not (True && True)
#+END_SRC

#+RESULTS:
: False

*Equality operators*

#+BEGIN_SRC haskell :exports both
  9 == 9
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  9 == 8
#+END_SRC

#+RESULTS:
: False

=/= means /not/ in the context of equality operators:
#+BEGIN_SRC haskell :exports both
  9 /= 9
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC haskell :exports both
  9 /= 8
#+END_SRC

#+RESULTS:
: True

We can compare strings as well:
#+BEGIN_SRC haskell :exports both
  "yo" == "yo"
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell :exports both
  "yo" == "no"
#+END_SRC

#+RESULTS:
: False

** Functions
Syntax for functions:

#+BEGIN_SRC haskell :exports both
  min 8 9
#+END_SRC

#+RESULTS:
: 8

So it's the function name followed by input arguments. Another example:

#+BEGIN_SRC haskell :exports both
  succ 19
#+END_SRC

#+RESULTS:
: 20

Calling a function takes highest precedence:

#+BEGIN_SRC haskell :exports both
  succ 5 + max 2 3 + 1
#+END_SRC

#+RESULTS:
: 10

The above is equivalent to:

#+BEGIN_SRC haskell :exports both
  (succ 5) + (max 2 3) + 1
#+END_SRC

#+RESULTS:
: 10

Above functions are of type =prefix= i.e. function name comes before the arguments. 
Another syntax for writing functions in haskell is =infix=:

#+BEGIN_SRC haskell :exports both
  5 * 4
#+END_SRC

#+RESULTS:
: 20

Wait, =*= is an operator, right? Everything in haskell is a function, even operators.
Anyways, =infix= means the name is at the center of the two arguments. Yes, =infix= is
only valid for 2 arguments. 

Any function that takes two arguments can always be represented using =infix= syntax:

#+BEGIN_SRC haskell :exports both
  87 `div` 10
#+END_SRC

#+RESULTS:
: 8

Okay, that's how functions are called. They are defined in a similar way:

#+BEGIN_SRC haskell :exports both
  let doubleUs x y = x*2 + y*2
  doubleUs 1 2
#+END_SRC

#+RESULTS:
: 6

The =let= here is just to provide the definition to the haskell interpreter. If we had a script that we were
compiling, we won't need that. To load that script though, we'd need to say =:l funcName=

So we saw the syntax is function name followed by input arguments followed by
= followed by an expression that calculates the output.

Haskell functions are pure, more about that later.

Haskell functions also can not begin with a capital letter. We'll see why later.

** Conditionals

Alright, this is how we write conditionals:

#+BEGIN_SRC haskell :exports both
  let doubleSmallNumber x = if x > 100 then x else 2*x
  doubleSmallNumber 40
#+END_SRC

#+RESULTS:
: 80

#+BEGIN_SRC haskell :exports both
  doubleSmallNumber 500
#+END_SRC

#+RESULTS:
: 500

Note that conditionals /always/ need an else. This is because in haskell, an if statement is an
expression meaning that it has to return a value, or in other words, evaluate to something.

** Lists
Lists in haskell are actually implemented as singly linked lists. Infact, they are as simple as:

#+BEGIN_SRC haskell :exports code
  data MyList a = Nil | Cons a (MyList a)
#+END_SRC

Haskell has a lot of tricks in its bag when it comes to list manipulation. Also, because of laziness, lists
are used as iterators and they give /acceptable/ performance. Examples later would help demonstrate this.

Lists is a =homogenous= data structure in haskell i.e. it only stores elements of the same type.

As an example, String in haskell is just a list of characters.

There are many commands in this section, so let's just look at code and hopefully that should be self-explanatory:

#+BEGIN_SRC haskell :exports both
  let myList = [4,77,17,23,55]
  myList
#+END_SRC

#+RESULTS:
| 4 | 77 | 17 | 23 | 55 |

#+BEGIN_SRC haskell :exports both
  myList ++ [1,2,3]
#+END_SRC

#+RESULTS:
| 4 | 77 | 17 | 23 | 55 | 1 | 2 | 3 | 

#+BEGIN_SRC haskell :exports both
  99 : myList
#+END_SRC  

#+RESULTS:
| 99 | 4 | 77 | 17 | 23 | 55 |

#+BEGIN_SRC haskell :exports both
  'C' : "AN JOIN BECAUSE STRINGS ARE LIST OF CHARS!"
#+END_SRC  

#+RESULTS:
: CAN JOIN BECAUSE STRINGS ARE LIST OF CHARS!

#+BEGIN_SRC haskell :exports both
  myList !! 3
#+END_SRC  

#+RESULTS:
: 23

#+BEGIN_SRC haskell :exports both
  head [1,2,3]
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC haskell :exports both
  tail [1,2,3]
#+END_SRC

#+RESULTS:
| 2 | 3 |

#+BEGIN_SRC haskell :exports both
  init [1,2,3]
#+END_SRC

#+RESULTS:
| 1 | 2 |

#+BEGIN_SRC haskell :exports both
  last [1,2,3]
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC haskell :exports both
  null [1,2,3]
#+END_SRC

#+RESULTS:
: False

#+BEGIN_SRC haskell :exports both
  reverse [1,2,3]
#+END_SRC

#+RESULTS:
| 3 | 2 | 1 |

*** List Ranges

Again, let's go through some code which should be self-explanatory:

#+BEGIN_SRC haskell :exports both
  [1..10]
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

#+BEGIN_SRC haskell :exports both
  [1,2..10]
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

#+BEGIN_SRC haskell :exports both
  [10,9..1]
#+END_SRC

#+RESULTS:
| 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |

#+BEGIN_SRC haskell :exports both
  [1,3..10]
#+END_SRC

#+RESULTS:
| 1 | 3 | 5 | 7 | 9 |

#+BEGIN_SRC haskell :exports both
  [2,4..20]
#+END_SRC

#+RESULTS:
| 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |

Floating point stepping can be funky, so better not go there:
#+BEGIN_SRC haskell :exports both
  [0.1,0.3..1]
#+END_SRC

#+RESULTS:
| 0.1 | 0.3 | 0.5 | 0.7 | 0.8999999999999999 | 1.0999999999999999 |

#+BEGIN_SRC haskell :exports both
  ['a'..'z']
#+END_SRC

#+RESULTS:
: abcdefghijklmnopqrstuvwxyz

You can also step by 2 letters (pretty cool, 'an?):

#+BEGIN_SRC haskell :exports both
  ['a','c'..'z']
#+END_SRC

#+RESULTS:
: acegikmoqsuwy

#+BEGIN_SRC haskell :exports both
  ['S'..'Z']
#+END_SRC

#+RESULTS:
: STUVWXYZ

#+BEGIN_SRC haskell :exports both
  [13,26..7*13]
#+END_SRC

#+RESULTS:
| 13 | 26 | 39 | 52 | 65 | 78 | 91 | 

Another way using =take= function:

#+BEGIN_SRC haskell :exports both
  take 7 [13,26..]
#+END_SRC

#+RESULTS:
| 13 | 26 | 39 | 52 | 65 | 78 | 91 |

Wait, we can have infinite lists !? Well, yes:

#+BEGIN_SRC haskell :exports code
  [1,2,..]
#+END_SRC

But don't try to execute it. Haskell is lazy but once we try to evaluate this expression, it'll
want to calculate all numbers to infinity. That takes /infinite/ time then, which clearly we don't have.
The earlier example worked because =take= took /7/ as an argument so haskell knows we need only /7/
elements of the infinite list, atleast for now. This is why laziness is really powerful!

#+BEGIN_SRC haskell :exports both
  take 10 (cycle [1,2,3])
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 1 | 2 | 3 | 1 | 2 | 3 | 1 |

=cycle= function just repeats the list to produce an infinite list. This example worked
because we used the =take= function again, which tells haskell we only need 10 elements of
this infinite list.

Similar to =cycle= function is =repeat= which is like =cycle= but with one element only:

#+BEGIN_SRC haskell :exports both
  take 10 (repeat 5)
#+END_SRC

#+RESULTS:
| 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |

Can also use =replicate=:

#+BEGIN_SRC haskell :exports both
  replicate 3 10
#+END_SRC

#+RESULTS:
| 10 | 10 | 10 |

*** List Comprehensions

List comprehensions are one of the reasons haskell has concise and expressive syntax. 

List comprehensions are very similar to [[https://en.wikipedia.org/wiki/Set-builder_notation][Set Comprehensions]] in math.

Let's look at a list comprehension:

#+BEGIN_SRC haskell :exports both
  [x*2 | x <- [1..10]]
#+END_SRC

#+RESULTS:
| 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |

This is how the above code expression would read:
=x= is drawn from the list =[1..10]= and for /every/ element in this list, multiply
it by 2 or =x*2=. The final result is a list again.

Note that in haskell, =x <- [1..10]= means =[1..10]= is bound to =x=.

Let's go one step further; we can apply filters or predicates:

#+BEGIN_SRC haskell :exports both
  [x*2 | x <- [1..10], x*2 > 13]
#+END_SRC

#+RESULTS:
| 14 | 16 | 18 | 20 |

This now says the same thing as before, but now, after the result is evaulated,
we filter them using the =x*2 > 13= predicate before the list is finalized. 

We can also have multiple predicates:

#+BEGIN_SRC haskell :exports both
  [x*2 | x <- [1..10], x*2 > 13, x*2 < 17]
#+END_SRC

#+RESULTS:
| 14 | 16 |

Note that the two predicates here have an /and/ relationship i.e. both must be met
before the elements can go into the final list.

We can draw from multiple lists as well:

#+BEGIN_SRC haskell :exports both
  [x*y | x <- [2,5,10], y <- [8,10,11]]
#+END_SRC

#+RESULTS:
| 16 | 20 | 22 | 40 | 50 | 55 | 80 | 100 | 110 | 

Without filters, the length is =3*3= or =9= as expected.
Let's apply a filter now:

#+BEGIN_SRC haskell :exports both
  [x*y | x <- [2,5,10], y <- [8,10,11], x*y>50]
#+END_SRC

#+RESULTS:
| 55 | 80 | 100 | 110 |

** Tuples

At first tuples may seem like lists, but there are two keys differences:
- Lists are homogenous i.e. all elements have to have the same type e.g. integer. Tuples on
the other hand can have elements of different types.
- The type of a list is defined only by the type of its elements i.e. =[1,2,3]= is a list of ints. For tuples,
however, the type is defined not only by the types of its elements but also by the /number/ of elements i.e. a
tuple with 2 ints is different from a tuple with 3 ints which is different from a tuple with 2 ints and 1 string.

Let's take a look at a simple example:

#+BEGIN_SRC haskell :exports both
  (1,3,"string",'c',5.09)
#+END_SRC

#+RESULTS:
| 1 | 3 | string | c | 5.09 |

A tuple with 2 elements is called a /pair/:

#+BEGIN_SRC haskell :exports both
  (8,11)
#+END_SRC

#+RESULTS:
| 8 | 11 |

Haskell has functions just for pairs:

#+BEGIN_SRC haskell :exports both
  fst (8,11)
#+END_SRC

#+RESULTS:
: 8

#+BEGIN_SRC haskell :exports both
  snd (8,11)
#+END_SRC

#+RESULTS:
: 11

By extension, tuples with 3 elements are called /triplets/. After that, they are called
/4-tuples/, /5-tuples/ etc.

Tuples are more rigid; think of how we can make a list of 2-D vectors. One way is:

#+BEGIN_SRC haskell :exports both
  [ [1,2], [8,11], [4,5] ]
#+END_SRC

#+RESULTS:
| 1 |  2 |
| 8 | 11 |
| 4 |  5 | 

Well, this sort of works but now someone can do:

#+BEGIN_SRC haskell :exports both
  [ [1,2], [8,11,15], [4,5] ]
#+END_SRC

#+RESULTS:
| 1 |  2 |    |
| 8 | 11 | 15 |
| 4 |  5 |    |

This works but shouldn't. Answer is unsurprisingly, tuples:

#+BEGIN_SRC haskell :exports both
  [ (1,2), (8,11), (4,5) ]
#+END_SRC

#+RESULTS:
| 1 |  2 |
| 8 | 11 |
| 4 |  5 | 

Now no one can do:

#+BEGIN_SRC haskell :exports both
  [ (1,2), (8,11,15), (4,5) ]
#+END_SRC

#+RESULTS:
: <interactive>:34:10:
:     Couldn't match expected type `(t, t1)'
:                 with actual type `(Integer, Integer, Integer)'
:     Relevant bindings include
:       it :: [(t, t1)] (bound at <interactive>:34:1)
:     In the expression: (8, 11, 15)
:     In the expression: [(1, 2), (8, 11, 15), (4, 5)]
:     In an equation for `it': it = [(1, 2), (8, 11, 15), (4, 5)]

Heck, they can't even do this:

#+BEGIN_SRC haskell :exports both
  [ (1,2), (8,11), ("four",5) ]
#+END_SRC

#+RESULTS:
: <interactive>:36:4:
:     Could not deduce (Num [Char]) arising from the literal `1'
:     from the context (Num t)
:       bound by the inferred type of it :: Num t => [([Char], t)]
:       at <interactive>:36:1-29
:     In the expression: 1
:     In the expression: (1, 2)
:     In the expression: [(1, 2), (8, 11), ("four", 5)]

This is because, as discussed earlier, type of tuples encodes both
the type of all of its elements as well as the total number of elements.

Finally, let's look at the very useful, =zip= function:

#+BEGIN_SRC haskell :exports both
  zip [1..5] ['a'..'e']
#+END_SRC

#+RESULTS:
| 1 | a |
| 2 | b |
| 3 | c |
| 4 | d |
| 5 | e |

As we see, it takes in two lists, and stiches them element-by-element forming a list of pairs.
Note that if the lists have different lengths, it picks the minimum of the lengths:

#+BEGIN_SRC haskell :exports both
  zip [1..3] ['a'..'e']
#+END_SRC

#+RESULTS:
| 1 | a |
| 2 | b |
| 3 | c | 
 
